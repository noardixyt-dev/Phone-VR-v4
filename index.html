<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Stereo Viewer — Rear camera per-eye + world-locked menu</title>
<style>
  :root { --outline: rgba(255,255,255,0.06); }
  html,body{margin:0;padding:0;height:100%;width:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
  /* canvas overlay for 3D menu */
  canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;z-index:40;pointer-events:none;display:block}
  /* stereo container: bottom-anchored, windows grow upwards */
  #stereoWrap{position:fixed;inset:0;display:flex;justify-content:center;align-items:flex-end;gap:var(--gap,12px);padding-bottom:12px;pointer-events:none;z-index:10}
  .eyeWin{width:var(--eye-w,360px);height:var(--eye-h,240px);border-radius:14px;overflow:hidden;border:2px solid var(--outline);box-shadow:0 6px 22px rgba(0,0,0,0.6);background:#000;position:relative}
  .eyeVideo{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform-origin:center center}
  /* UI */
  #controls{position:fixed;left:12px;top:10px;z-index:60;display:flex;gap:10px;align-items:center;pointer-events:auto;transition:opacity .32s,transform .32s}
  #controls.hidden{opacity:0;pointer-events:none;transform:translateY(-8px)}
  .control{background:rgba(0,0,0,0.45);backdrop-filter:blur(6px);padding:8px;border-radius:8px;font-size:13px;color:#fff}
  #fovSlider{width:220px}
  #fullscreenBtn{position:fixed;top:10px;right:10px;z-index:60;padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.06);color:#fff;font-size:14px;pointer-events:auto;display:none}
  #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:80;padding:14px 18px;border-radius:10px;background:#111;color:#fff;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
  #hint{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);font-size:12px;background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:8px;z-index:60}
  #portraitOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:120;color:#fff;font-size:20px;padding:20px;text-align:center;pointer-events:auto}
</style>
</head>
<body>
  <button id="startBtn">Start VR (camera & motion)</button>

  <div id="controls" class="hidden" style="display:none">
    <div class="control">
      <div style="font-size:12px;margin-bottom:6px">FOV (eye window) <span id="fovVal">70%</span></div>
      <input id="fovSlider" type="range" min="40" max="100" value="70" />
    </div>
  </div>

  <button id="fullscreenBtn">Fullscreen</button>
  <div id="hint">Double-tap to toggle anchored menu • Tap top to show UI</div>

  <div id="portraitOverlay">Please rotate your device to landscape</div>

  <div id="stereoWrap" aria-hidden="true">
    <div id="leftWin" class="eyeWin"><video id="videoLeft" class="eyeVideo" playsinline autoplay muted></video></div>
    <div id="rightWin" class="eyeWin"><video id="videoRight" class="eyeVideo" playsinline autoplay muted></video></div>
  </div>

  <canvas id="overlay"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>
/*
  This file:
  - attaches the same rear camera stream to two <video> elements (one per eye)
  - renders a world-locked 3DOF menu twice (left/right) on the overlay canvas via three.js
  - preserves bottom-anchored eye windows that grow upward with the FOV slider
  - UI top-left slider, top-right fullscreen, tap top to show, auto-hide after 10s
*/

const startBtn = document.getElementById('startBtn');
const controls = document.getElementById('controls');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const fovSlider = document.getElementById('fovSlider');
const fovVal = document.getElementById('fovVal');
const hint = document.getElementById('hint');
const portraitOverlay = document.getElementById('portraitOverlay');

const leftWin = document.getElementById('leftWin');
const rightWin = document.getElementById('rightWin');
const videoLeft = document.getElementById('videoLeft');
const videoRight = document.getElementById('videoRight');
const overlay = document.getElementById('overlay');

let stream = null;
let eyeScalePct = parseFloat(fovSlider.value);
fovVal.textContent = Math.round(eyeScalePct) + '%';

let uiHideTimer = null;
const UI_HIDE_MS = 10000;
function showUI(){ controls.style.display='flex'; controls.classList.remove('hidden'); fullscreenBtn.style.display='block'; resetUIHideTimer(); }
function hideUI(){ controls.classList.add('hidden'); fullscreenBtn.style.display='none'; }
function resetUIHideTimer(){ if(uiHideTimer) clearTimeout(uiHideTimer); uiHideTimer = setTimeout(()=>{ hideUI(); }, UI_HIDE_MS); }

window.addEventListener('pointermove', ()=> resetUIHideTimer(), { passive:true });
controls.addEventListener('pointerdown', ()=> showUI());

/* device orientation helpers (landscape calibrated + remove roll) */
const zee = new THREE.Vector3(0,0,1);
const qPortraitToThree = new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
let deviceQuat = new THREE.Quaternion();
let deviceOrientationEnabled = false;
function getScreenOrientationDeg(){ if(screen && screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle; return window.orientation || 0; }
function setObjectQuaternionFromSensor(quatOut, alpha, beta, gamma){
  const orient = getScreenOrientationDeg();
  const deg = Math.PI/180;
  const e = new THREE.Euler((beta||0)*deg, (alpha||0)*deg, -(gamma||0)*deg, 'YXZ');
  quatOut.setFromEuler(e);
  let baseRot = new THREE.Quaternion();
  if (orient === 90) baseRot.setFromAxisAngle(zee, -Math.PI/2);
  else if (orient === -90 || orient === 270) baseRot.setFromAxisAngle(zee, Math.PI/2);
  else if (orient === 180) baseRot.setFromAxisAngle(zee, Math.PI);
  quatOut.multiply(qPortraitToThree);
  quatOut.multiply(baseRot);
  const ex = new THREE.Euler().setFromQuaternion(quatOut,'YXZ'); ex.z = 0; quatOut.setFromEuler(ex);
}
async function enableDeviceOrientation(){
  if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
    try{
      const perm = await DeviceOrientationEvent.requestPermission();
      if (perm === 'granted') window.addEventListener('deviceorientation', ev=>{ deviceOrientationEnabled=true; setObjectQuaternionFromSensor(deviceQuat, ev.alpha, ev.beta, ev.gamma); }, true);
      else window.addEventListener('deviceorientation', ev=>{ deviceOrientationEnabled=true; setObjectQuaternionFromSensor(deviceQuat, ev.alpha, ev.beta, ev.gamma); }, true);
    }catch(e){ window.addEventListener('deviceorientation', ev=>{ deviceOrientationEnabled=true; setObjectQuaternionFromSensor(deviceQuat, ev.alpha, ev.beta, ev.gamma); }, true); }
  } else {
    window.addEventListener('deviceorientation', ev=>{ deviceOrientationEnabled=true; setObjectQuaternionFromSensor(deviceQuat, ev.alpha, ev.beta, ev.gamma); }, true);
  }
}

/* pick rear camera device id heuristically */
async function chooseRearDeviceId(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d=>d.kind==='videoinput');
    for(const c of cams){
      const L=(c.label||'').toLowerCase();
      if(L.includes('back')||L.includes('rear')||L.includes('environment')||L.includes('main')||L.includes('wide')) return c.deviceId;
    }
    for(const c of cams){
      const L=(c.label||'').toLowerCase();
      if(!L.includes('front') && !L.includes('selfie')) return c.deviceId;
    }
    return cams.length?cams[0].deviceId:null;
  }catch(e){ return null; }
}

/* try multiple resolution/fps combos */
async function startCameraStream(){
  const deviceId = await chooseRearDeviceId();
  const tryRes = [{w:3840,h:2160},{w:1920,h:1080},{w:1280,h:720}];
  const fps = [60,30];
  for(const r of tryRes){
    for(const f of fps){
      try{
        const constraints = deviceId ? { video:{ deviceId:{ exact: deviceId }, width:{ ideal: r.w }, height:{ ideal: r.h }, frameRate:{ ideal: f } }, audio:false }
                                     : { video:{ facingMode:{ ideal: 'environment' }, width:{ ideal: r.w }, height:{ ideal: r.h }, frameRate:{ ideal: f } }, audio:false };
        const s = await navigator.mediaDevices.getUserMedia(constraints);
        return s;
      }catch(e){ /* continue */ }
    }
  }
  return navigator.mediaDevices.getUserMedia({ video:true, audio:false });
}

/* START button */
startBtn.addEventListener('click', async ()=>{
  startBtn.style.display='none';
  await enableDeviceOrientation();
  showUI();
  try{
    stream = await startCameraStream();
    // attach same stream to both videos
    videoLeft.srcObject = stream;
    videoRight.srcObject = stream;
    // make sure they play (some browsers require user gesture — start button satisfies this)
    try { await videoLeft.play(); } catch(e){ console.warn('left play blocked', e); }
    try { await videoRight.play(); } catch(e){ console.warn('right play blocked', e); }
    // reveal controls & fullscreen
    controls.style.display='flex';
    fullscreenBtn.style.display='block';
    // init three overlay for menu after camera started
    initThreeOverlay();
  }catch(err){
    console.error('camera start failed', err);
    alert('Camera access failed: ' + (err && err.message ? err.message : err));
    startBtn.style.display='block';
  }
});

/* fullscreen toggle */
fullscreenBtn.addEventListener('click', ()=> {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
  resetUIHideTimer();
});

/* FOV slider */
fovSlider.addEventListener('input', ()=> {
  eyeScalePct = parseFloat(fovSlider.value);
  fovVal.textContent = Math.round(eyeScalePct) + '%';
  layoutEyes();
  // menu scale follows
  if (menuMesh) {
    const s = eyeScalePct / 70;
    menuMesh.scale.setScalar(s);
  }
  resetUIHideTimer();
});

/* layout eyes bottom-anchored, grow upward */
function layoutEyes(){
  const scale = Math.max(0.3, Math.min(1.0, eyeScalePct/100));
  let eyeH = Math.round(window.innerHeight * scale);
  let eyeW = Math.floor(eyeH * 1.5);
  let gap = Math.max(8, Math.round(eyeW * 0.06));
  if (eyeW * 2 + gap > window.innerWidth){
    const avail = window.innerWidth - gap;
    eyeW = Math.floor(avail / 2);
    eyeH = Math.floor(eyeW * 2/3);
  }
  document.documentElement.style.setProperty('--eye-w', eyeW + 'px');
  document.documentElement.style.setProperty('--eye-h', eyeH + 'px');
  document.documentElement.style.setProperty('--gap', gap + 'px');
  // Because stereoWrap uses align-items:flex-end, the windows remain bottom anchored and grow upward
}

/* portrait overlay */
function updatePortrait(){
  if (window.innerHeight > window.innerWidth){
    portraitOverlay.style.display = 'flex';
    // also block UI
    controls.classList.add('hidden');
    fullscreenBtn.style.display='none';
  } else {
    portraitOverlay.style.display = 'none';
    // restore UI display based on whether it should be visible
    if (!controls.classList.contains('hidden')) controls.style.display='flex';
    if (controls.style.display !== 'none') fullscreenBtn.style.display='block';
  }
}

/* -------------- THREE overlay (menu) -------------- */
let renderer, scene3D, perspectiveBase, camLeft, camRight;
let menuMesh = null;
let menuBar = null;
const FIXED_IPD = 0.064;

function initThreeOverlay(){
  // renderer
  renderer = new THREE.WebGLRenderer({ canvas: overlay, antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = false;

  // scene
  scene3D = new THREE.Scene();
  scene3D.add(new THREE.AmbientLight(0xffffff,0.8));
  const dl = new THREE.DirectionalLight(0xffffff,0.25); dl.position.set(1,2,2); scene3D.add(dl);

  // camera
  perspectiveBase = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
  camLeft = perspectiveBase.clone();
  camRight = perspectiveBase.clone();

  // menu geometry/material
  const boxG = new THREE.BoxGeometry(0.48, 0.28, 0.02);
  const boxM = new THREE.MeshStandardMaterial({ color:0x1f6feb, roughness:0.5, metalness:0.05, emissive:0x001030 });
  menuMesh = new THREE.Mesh(boxG, boxM);
  menuMesh.visible = false;
  scene3D.add(menuMesh);

  // pill bar
  const barG = new THREE.BoxGeometry(0.28, 0.028, 0.002);
  const barM = new THREE.MeshStandardMaterial({ color:0xffffff, transparent:true, opacity:0.9 });
  menuBar = new THREE.Mesh(barG, barM);
  menuBar.position.set(0, - (0.28/2 + 0.028/2 + 0.01), 0.012);
  menuMesh.add(menuBar);

  // input for dragging menu via bar
  window.addEventListener('pointerdown', overlayPointerDown, { passive:true });
  window.addEventListener('pointermove', overlayPointerMove, { passive:true });
  window.addEventListener('pointerup', overlayPointerUp, { passive:true });

  window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); perspectiveBase.aspect = window.innerWidth / window.innerHeight; perspectiveBase.updateProjectionMatrix(); layoutEyes(); updatePortrait(); });

  layoutEyes();
  updatePortrait();
  animate();
}

/* menu behavior: spawn world-locked in front of viewer (3DOF) and face horizontally */
function spawnMenu(){
  const forward = new THREE.Vector3(0,0,-1);
  if (deviceOrientationEnabled) forward.applyQuaternion(deviceQuat);
  const spawnPos = forward.clone().multiplyScalar(1.4); // distance
  menuMesh.position.copy(spawnPos);
  // face horizontally toward origin (camera at origin)
  const toCam = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), menuMesh.position);
  toCam.y = 0;
  menuMesh.lookAt(menuMesh.position.clone().add(toCam));
  menuMesh.up.set(0,1,0);
  const baseScale = eyeScalePct / 70;
  menuMesh.scale.setScalar(baseScale);
  menuMesh.visible = true;
  popScale(menuMesh, baseScale, 240);
}

function hideMenu(){
  shrinkHide(menuMesh, 160);
}

/* spawn/hide toggle via double-tap */
let lastTap = 0;
function toggleMenu() {
  if (!menuMesh || !renderer) return;
  if (!menuMesh.visible) spawnMenu(); else hideMenu();
}

/* simple easing helpers */
function popScale(obj, target=1, dur=220){
  const start = performance.now();
  const sx = obj.scale.x;
  function step(now){
    const t = Math.min(1, (now-start)/dur);
    const e = 1 - Math.pow(1-t,3);
    const v = sx + (target - sx) * e;
    obj.scale.set(v,v,v);
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}
function shrinkHide(obj, dur=160){
  const start = performance.now(); const sx = obj.scale.x;
  function step(now){
    const t = Math.min(1, (now-start)/dur);
    const e = Math.pow(1 - t, 2);
    obj.scale.set(sx*e, sx*e, sx*e);
    if (t < 1) requestAnimationFrame(step);
    else { obj.visible = false; obj.scale.set(sx,sx,sx); }
  }
  requestAnimationFrame(step);
}

/* drag handling: move menu along camera plane when dragging the pill */
let dragging=false, dragStart=null, dragCam=null;
const raycaster = new THREE.Raycaster();
function screenToNDC(x,y){ return new THREE.Vector2((x/window.innerWidth)*2 - 1, - (y/window.innerHeight)*2 + 1); }

function overlayPointerDown(e){
  const now = Date.now();
  if (now - lastTap < 300){
    // double tap: toggle menu
    toggleMenu();
  }
  lastTap = now;

  if (!menuMesh.visible) return;
  const ndc = screenToNDC(e.clientX, e.clientY);
  raycaster.setFromCamera(ndc, camLeft);
  const hits = raycaster.intersectObject(menuBar, true);
  if (hits.length > 0){
    dragging = true;
    dragStart = { x: e.clientX, y: e.clientY, startPos: menuMesh.position.clone() };
    dragCam = perspectiveBase;
  }
}
function overlayPointerMove(e){
  if (!dragging || !dragStart) return;
  const ndcNow = screenToNDC(e.clientX, e.clientY);
  const ndcThen = screenToNDC(dragStart.x, dragStart.y);
  const delta = ndcNow.clone().sub(ndcThen);
  const cam = dragCam;
  const distance = menuMesh.position.length() || 1.4;
  const vFov = cam.fov * Math.PI/180;
  const worldH = 2 * Math.tan(vFov/2) * distance;
  const worldW = worldH * cam.aspect;
  const worldDelta = new THREE.Vector3(-delta.x * worldW/2, -delta.y * worldH/2, 0);
  worldDelta.applyQuaternion(cam.quaternion);
  menuMesh.position.copy(dragStart.startPos.clone().add(worldDelta));
}
function overlayPointerUp(e){ dragging=false; dragStart=null; }

/* hover visual (center gaze) pulse on menuBar for feedback */
function hoverPulse(){
  if (!menuMesh || !menuMesh.visible) return;
  const ndc = new THREE.Vector2(0,0); // center
  raycaster.setFromCamera(ndc, camLeft);
  const hits = raycaster.intersectObject(menuBar, true);
  if (hits.length > 0){
    menuBar.material.opacity = 1.0;
    menuBar.material.emissive = new THREE.Color(0xaaaaaa);
  } else {
    menuBar.material.opacity = 0.9;
    menuBar.material.emissive = new THREE.Color(0x000000);
  }
}

/* render loop: render scene3D twice (left and right) with scissor/viewport for each eye window */
function animate(){
  requestAnimationFrame(animate);
  if (!renderer) return;

  if (deviceOrientationEnabled) perspectiveBase.quaternion.copy(deviceQuat);
  else perspectiveBase.quaternion.identity();

  // set cameras and render per eye using DOM eye window bounds
  const leftRect = leftWin.getBoundingClientRect();
  const rightRect = rightWin.getBoundingClientRect();
  const leftViewportY = window.innerHeight - leftRect.top - leftRect.height;

  renderer.setScissorTest(true);

  // left eye
  renderer.setScissor(leftRect.left, leftViewportY, leftRect.width, leftRect.height);
  renderer.setViewport(leftRect.left, leftViewportY, leftRect.width, leftRect.height);
  renderer.clear();
  camLeft.position.set(-FIXED_IPD/2, 0, 0);
  camLeft.quaternion.copy(perspectiveBase.quaternion);
  camLeft.updateMatrixWorld();
  renderer.clearDepth();
  renderer.render(scene3D, camLeft);

  // right eye
  const rightViewportY = window.innerHeight - rightRect.top - rightRect.height;
  renderer.setScissor(rightRect.left, rightViewportY, rightRect.width, rightRect.height);
  renderer.setViewport(rightRect.left, rightViewportY, rightRect.width, rightRect.height);
  camRight.position.set(FIXED_IPD/2, 0, 0);
  camRight.quaternion.copy(perspectiveBase.quaternion);
  camRight.updateMatrixWorld();
  renderer.clearDepth();
  renderer.render(scene3D, camRight);

  renderer.setScissorTest(false);

  hoverPulse();
}

/* top tap reveal UI */
window.addEventListener('pointerdown', (ev)=>{ if (ev.clientY <= 120) showUI(); });

/* initial */
layoutEyes();
updatePortrait();
window.addEventListener('resize', ()=>{ layoutEyes(); updatePortrait(); if (renderer) { renderer.setSize(window.innerWidth, window.innerHeight); perspectiveBase.aspect = window.innerWidth/window.innerHeight; perspectiveBase.updateProjectionMatrix(); } });

</script>
</body>
</html>
