<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Phone VR Viewer — improved</title>
<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #controls{position:absolute;z-index:30;left:12px;top:10px;display:flex;gap:10px;align-items:center}
  .control{background:rgba(0,0,0,0.4);backdrop-filter:blur(6px);padding:8px;border-radius:8px;font-size:13px}
  #fovSlider,#eyeAspectSlider{width:160px}
  #fullscreenBtn{position:absolute;top:10px;right:10px;z-index:30;padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.06);color:#fff;font-size:14px}
  #startBtn{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:14px 20px;border-radius:10px;background:#111;color:#fff;z-index:40;border:1px solid rgba(255,255,255,0.06);font-size:16px}
  #labelSmall{font-size:12px;opacity:0.9}
  /* small hint at bottom */
  #hint{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);font-size:12px;opacity:0.7;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,0.35);z-index:20}
  /* hide video element */
  video { display:none !important; }
</style>
</head>
<body>
  <div id="controls" aria-hidden="true" style="display:none">
    <div class="control">
      <div id="labelSmall">Camera FOV <span id="fovVal">70°</span></div>
      <input id="fovSlider" type="range" min="30" max="120" value="70" />
    </div>
    <div class="control">
      <div id="labelSmall">Eye width:height <span id="eyeAspectVal">1.50</span></div>
      <input id="eyeAspectSlider" type="range" min="100" max="180" value="150" />
    </div>
  </div>

  <button id="fullscreenBtn" style="display:none">Fullscreen</button>
  <button id="startBtn">Tap to Start VR</button>
  <div id="hint">Double-tap to toggle menu • Drag to move cursor • Tap objects to click</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* Minimal comments — see TL;DR & pseudocode above. */

/* UI elements */
const fovSlider = document.getElementById('fovSlider');
const fovVal = document.getElementById('fovVal');
const eyeAspectSlider = document.getElementById('eyeAspectSlider');
const eyeAspectVal = document.getElementById('eyeAspectVal');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const startBtn = document.getElementById('startBtn');
const controls = document.getElementById('controls');

let renderer, scene, cameraBase, cameraLeft, cameraRight;
let video, videoTexture, videoPlane;
let cursorMesh, menuButtonMesh;
let interactiveObjects = [];
const raycaster = new THREE.Raycaster();
const pointerNDC = new THREE.Vector2(0, 0);
let INTERSECTED = null;
let menuVisible = false;
let lastTap = 0;
const baseIPD = 0.06; // meters scaled
let cameraFov = parseFloat(fovSlider.value); // degrees
let eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0; // e.g., 1.5 default
const planeDist = 1.5; // distance camera->video plane

/* Start / camera access */
startBtn.addEventListener('click', async () => {
  try {
    // user gesture: go fullscreen if possible
    if (document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen();
  } catch (e) { /* ignore */ }
  startBtn.style.display = 'none';
  fullscreenBtn.style.display = 'block';
  controls.style.display = 'flex';

  // create hidden video element and request camera
  video = document.createElement('video');
  video.setAttribute('playsinline','');
  video.autoplay = true;
  video.muted = true;
  document.body.appendChild(video);

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', async () => {
      try { await video.play(); } catch(e){ console.warn('video.play blocked', e); }
      initThreeJS();
    }, { once:true });
  } catch (err) {
    alert('Camera access denied or not available: ' + (err && err.message ? err.message : err));
    startBtn.style.display = 'block';
  }
});

/* Fullscreen toggle */
fullscreenBtn.addEventListener('click', () => {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
});

/* UI updates */
fovSlider.addEventListener('input', () => {
  cameraFov = parseFloat(fovSlider.value);
  fovVal.textContent = Math.round(cameraFov) + '°';
  if (cameraBase) {
    cameraBase.fov = cameraFov;
    cameraBase.updateProjectionMatrix();
    cameraLeft.fov = cameraRight.fov = cameraFov;
    cameraLeft.updateProjectionMatrix();
    cameraRight.updateProjectionMatrix();
    updateVideoPlane();
  }
});
eyeAspectSlider.addEventListener('input', () => {
  eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0;
  eyeAspectVal.textContent = eyeAspect.toFixed(2);
  if (cameraLeft) onWindowResize(); // recompute viewport sizes and camera.aspect
});

/* ThreeJS init */
function initThreeJS() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = true;
  renderer.setClearColor(0x000000, 1);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  cameraBase = new THREE.PerspectiveCamera(cameraFov, window.innerWidth / window.innerHeight, 0.01, 1000);
  cameraBase.position.set(0,0,0);
  cameraLeft = cameraBase.clone();
  cameraRight = cameraBase.clone();

  // lighting for menu items
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.5); dir.position.set(1,2,2); scene.add(dir);

  // setup video texture & plane that keeps video aspect intact
  videoTexture = new THREE.VideoTexture(video);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;
  const mat = new THREE.MeshBasicMaterial({ map: videoTexture, toneMapped: false });
  const geom = new THREE.PlaneGeometry(2, 1); // will be replaced by updateVideoPlane()
  videoPlane = new THREE.Mesh(geom, mat);
  videoPlane.material.side = THREE.DoubleSide;
  scene.add(videoPlane);

  // basic 3D menu button (toggle with double-tap)
  const box = new THREE.BoxGeometry(0.36, 0.18, 0.04);
  const boxMat = new THREE.MeshStandardMaterial({ color: 0x2f7fff, emissive: 0x000000, roughness: 0.5, metalness: 0.1 });
  menuButtonMesh = new THREE.Mesh(box, boxMat);
  menuButtonMesh.position.set(0, -0.2, -1.4);
  menuButtonMesh.visible = false;
  menuButtonMesh.userData = {
    type: 'button',
    onClick: () => {
      // simple action: toggle color
      menuButtonMesh.material.color.setHex(Math.floor(Math.random()*0xffffff));
    }
  };
  scene.add(menuButtonMesh);
  interactiveObjects.push(menuButtonMesh);

  // cursor
  const cursorGeo = new THREE.RingGeometry(0.01, 0.02, 24);
  const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
  cursorMesh.visible = false;
  scene.add(cursorMesh);

  // initial sizing
  updateVideoPlane();
  onWindowResize();
  window.addEventListener('resize', onWindowResize);

  // pointer interactions
  let pointerActive = false;
  window.addEventListener('pointermove', (ev) => {
    const x = (ev.clientX / window.innerWidth) * 2 - 1;
    const y = -(ev.clientY / window.innerHeight) * 2 + 1;
    pointerNDC.set(x, y);
    pointerActive = true;
  }, { passive:true });
  window.addEventListener('pointerdown', (ev) => {
    const now = Date.now();
    if (now - lastTap < 300) { // double-tap
      menuVisible = !menuVisible;
      menuButtonMesh.visible = menuVisible;
      cursorMesh.visible = menuVisible;
    }
    lastTap = now;
  });
  window.addEventListener('click', (ev) => {
    // perform raycast and click any interactive object
    updateRaycasterFromNDC(pointerNDC, cameraLeft);
    const intersects = raycaster.intersectObjects(interactiveObjects, true);
    if (intersects.length > 0 && intersects[0].object.userData && typeof intersects[0].object.userData.onClick === 'function') {
      intersects[0].object.userData.onClick();
    }
  });

  // animate
  animate();
}

/* compute plane size so it fills camera frustum at planeDist while keeping video aspect */
function updateVideoPlane() {
  if (!video || !video.videoWidth) return;
  const fovRad = THREE.MathUtils.degToRad(cameraBase.fov);
  const height = 2 * Math.tan(fovRad / 2) * planeDist;
  const videoAspect = video.videoWidth / video.videoHeight; // ~16/9
  const width = height * videoAspect;
  videoPlane.geometry.dispose();
  videoPlane.geometry = new THREE.PlaneGeometry(width, height);
  // place plane in front of base camera in world space
  const camWorldPos = new THREE.Vector3(); cameraBase.getWorldPosition(camWorldPos);
  const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(cameraBase.quaternion);
  const planePos = camWorldPos.clone().add(camDir.clone().multiplyScalar(planeDist));
  videoPlane.position.copy(planePos);
  videoPlane.quaternion.copy(cameraBase.quaternion);
}

/* create raycaster from a camera using given NDC coords */
function updateRaycasterFromNDC(ndc, cam) {
  raycaster.setFromCamera(ndc, cam);
}

/* viewport calculation:
   - desired per-eye size = window.innerHeight * eyeAspect
   - if total required width (2*eyeW) > window.width => scale down equally so both fit
   - center the two viewports horizontally within the canvas
*/
let cachedView = { leftX:0, leftW:0, rightX:0, rightW:0, eyeW:0, eyeH:0 };
function computeViewports() {
  let eyeH = window.innerHeight;
  let eyeW = Math.round(eyeH * eyeAspect);
  let totalW = eyeW * 2;
  let scale = 1;
  if (totalW > window.innerWidth) {
    scale = window.innerWidth / totalW;
    eyeW = Math.floor(eyeW * scale);
    eyeH = Math.floor(eyeH * scale);
    totalW = eyeW * 2;
  }
  // center horizontally
  const leftX = Math.floor((window.innerWidth - totalW) / 2);
  const rightX = leftX + eyeW;
  cachedView = { leftX, leftW: eyeW, rightX, rightW: eyeW, eyeW, eyeH };
  return cachedView;
}

/* handle resizing & recompute camera aspects & plane */
function onWindowResize() {
  if (!renderer) return;
  renderer.setSize(window.innerWidth, window.innerHeight);
  // compute per-eye viewport size based on eyeAspect and window height
  const v = computeViewports();
  // update left/right camera aspect to match per-eye viewport
  cameraLeft.aspect = v.leftW / v.eyeH;
  cameraRight.aspect = v.rightW / v.eyeH;
  cameraLeft.updateProjectionMatrix();
  cameraRight.updateProjectionMatrix();
  // keep base camera aspect as overall
  cameraBase.aspect = window.innerWidth / window.innerHeight;
  cameraBase.updateProjectionMatrix();

  // update video plane to match current camera FOV
  updateVideoPlane();
}

/* main loop */
function animate() {
  requestAnimationFrame(animate);
  if (!renderer) return;

  // keep video texture updated
  if (video && video.readyState >= video.HAVE_ENOUGH_DATA) {
    if (videoTexture) videoTexture.needsUpdate = true;
  }

  // raycaster & cursor placement: convert pointerNDC in screen space to cameraLeft
  // default center gaze if pointer not active
  const ndc = pointerNDC.clone();
  // if no pointer movement recently keep center
  // position cursor in world at distance slightly less than planeDist
  const cursorDist = 1.2;
  updateRaycasterFromNDC(ndc, cameraLeft);
  const origin = raycaster.ray.origin.clone();
  const dir = raycaster.ray.direction.clone();
  const worldCursor = origin.clone().add(dir.multiplyScalar(cursorDist));
  cursorMesh.position.copy(worldCursor);
  cursorMesh.lookAt(cameraLeft.getWorldPosition(new THREE.Vector3()));
  cursorMesh.scale.setScalar(cursorDist * 0.02);

  // manage intersection highlight if menu is visible
  if (menuVisible) {
    const intersects = raycaster.intersectObjects(interactiveObjects, false);
    if (intersects.length > 0) {
      const obj = intersects[0].object;
      if (INTERSECTED !== obj) {
        if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x000000);
        INTERSECTED = obj;
        if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x303030);
        cursorMesh.scale.multiplyScalar(1.6);
      }
    } else {
      if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x000000);
      INTERSECTED = null;
      cursorMesh.scale.setScalar(cursorDist * 0.02);
    }
  } else {
    if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x000000);
    INTERSECTED = null;
  }

  // IPD scaled slightly by fov (so slider has subtle stereo shift)
  const ipd = baseIPD * (1 + (cameraFov - 70) / 400); // mild effect
  cameraLeft.position.set(-ipd/2, 0, 0);
  cameraRight.position.set(ipd/2, 0, 0);
  cameraLeft.quaternion.copy(cameraBase.quaternion);
  cameraRight.quaternion.copy(cameraBase.quaternion);

  // render left and right using computed viewports
  renderer.clear();

  const v = cachedView; // computed in onWindowResize
  // left
  renderer.setViewport(v.leftX, 0, v.leftW, v.eyeH);
  renderer.setScissor(v.leftX, 0, v.leftW, v.eyeH);
  renderer.setScissorTest(true);
  renderer.render(scene, cameraLeft);

  // right
  renderer.setViewport(v.rightX, 0, v.rightW, v.eyeH);
  renderer.setScissor(v.rightX, 0, v.rightW, v.eyeH);
  renderer.setScissorTest(true);
  renderer.render(scene, cameraRight);

  renderer.setScissorTest(false);
}
</script>
</body>
</html>
