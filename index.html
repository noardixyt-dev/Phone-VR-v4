<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js";

const startBtn = document.getElementById("startBtn");
const controls = document.getElementById("controls");
const fullscreenBtn = document.getElementById("fullscreenBtn");
const fovSlider = document.getElementById("fovSlider");
const fovVal = document.getElementById("fovVal");
const leftOutline = document.getElementById("leftOutline");
const rightOutline = document.getElementById("rightOutline");
const portraitOverlay = document.getElementById("portraitOverlay");

let renderer, sceneVideo, scene3D, orthoCam;
let camLeft, camRight, perspectiveBase;
let videoEl, videoTexture;
let menuMesh;
let eyeScalePct = parseFloat(fovSlider.value);
const FIXED_IPD = 0.064;
const MENU_DISTANCE = 1.4;

fovVal.textContent = eyeScalePct + "%";

let deviceQuat = new THREE.Quaternion();
window.addEventListener("deviceorientation", (ev) => {
  const deg = Math.PI / 180;
  const e = new THREE.Euler(ev.beta * deg, ev.alpha * deg, -ev.gamma * deg, "YXZ");
  deviceQuat.setFromEuler(e);
});

startBtn.onclick = async () => {
  startBtn.style.display = "none";
  await startCamera();
  initScene();
  animate();
};

async function startCamera() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cam =
    devices.find((d) => d.kind === "videoinput" && d.label.toLowerCase().includes("back")) ||
    devices.find((d) => d.kind === "videoinput");
  const stream = await navigator.mediaDevices.getUserMedia({
    video: {
      deviceId: cam ? cam.deviceId : undefined,
      facingMode: { ideal: "environment" },
      width: { ideal: 3840 },
      height: { ideal: 2160 },
      frameRate: { ideal: 60 },
    },
  });

  videoEl = document.createElement("video");
  videoEl.srcObject = stream;
  videoEl.autoplay = true;
  videoEl.muted = true;
  videoEl.playsInline = true;
  document.body.appendChild(videoEl);
  videoEl.style.display = "none";

  await videoEl.play();

  videoTexture = new THREE.VideoTexture(videoEl);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;
}

function initScene() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- VIDEO PLANE SCENE ---
  sceneVideo = new THREE.Scene();
  orthoCam = new THREE.OrthographicCamera(0, window.innerWidth, 0, window.innerHeight, -10, 10);

  const uniforms = {
    map: { value: videoTexture },
    videoAspect: { value: 16 / 9 },
    targetAspect: { value: 1.5 },
  };

  const videoMat = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader: `
      varying vec2 vUv;
      uniform sampler2D map;
      uniform float videoAspect;
      uniform float targetAspect;
      void main(){
        vec2 uv=vUv;
        float va=videoAspect, ta=targetAspect;
        float sU=1.0,sV=1.0;
        if(va>ta){sU=ta/va;}else{sV=va/ta;}
        vec2 scaled=(uv-0.5)/vec2(sU,sV)+0.5;
        if(any(lessThan(scaled,vec2(0.0)))||any(greaterThan(scaled,vec2(1.0)))){
          gl_FragColor=vec4(0.0);
        }else{
          gl_FragColor=texture2D(map,scaled);
        }
      }`,
    depthWrite: false,
    depthTest: false,
  });

  const videoPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), videoMat);
  videoPlane.layers.set(0);
  sceneVideo.add(videoPlane);

  // --- 3D SCENE ---
  scene3D = new THREE.Scene();
  const light = new THREE.DirectionalLight(0xffffff, 0.4);
  light.position.set(1, 1, 1);
  scene3D.add(light);
  scene3D.add(new THREE.AmbientLight(0xffffff, 0.6));

  const menuGeo = new THREE.BoxGeometry(0.5, 0.3, 0.02);
  const menuMat = new THREE.MeshStandardMaterial({ color: 0x1f6feb });
  menuMesh = new THREE.Mesh(menuGeo, menuMat);
  menuMesh.position.z = -MENU_DISTANCE;
  scene3D.add(menuMesh);

  perspectiveBase = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
  camLeft = perspectiveBase.clone();
  camRight = perspectiveBase.clone();

  computeEyeRects();
}

function computeEyeRects() {
  const scale = eyeScalePct / 100;
  const h = window.innerHeight * scale;
  const w = h * 1.5;
  const gap = Math.round(w * 0.05);
  const totalW = w * 2 + gap;
  const leftX = (window.innerWidth - totalW) / 2;
  const topY = (window.innerHeight - h) / 2;

  leftOutline.style.cssText = `left:${leftX}px;top:${topY}px;width:${w}px;height:${h}px;display:block;`;
  rightOutline.style.cssText = `left:${leftX + w + gap}px;top:${topY}px;width:${w}px;height:${h}px;display:block;`;

  return { leftX, topY, w, h, gap };
}

function animate() {
  requestAnimationFrame(animate);
  if (!renderer) return;

  if (videoEl && videoEl.readyState >= 2 && videoTexture) {
    videoTexture.needsUpdate = true;
  }

  perspectiveBase.quaternion.copy(deviceQuat);
  const rect = computeEyeRects();

  const leftY = window.innerHeight - rect.topY - rect.h;

  // --- LEFT EYE ---
  renderer.setScissorTest(true);
  renderer.setScissor(rect.leftX, leftY, rect.w, rect.h);
  renderer.setViewport(rect.leftX, leftY, rect.w, rect.h);
  renderer.clear();
  renderer.render(sceneVideo, orthoCam);
  camLeft.position.set(-FIXED_IPD / 2, 0, 0);
  camLeft.quaternion.copy(perspectiveBase.quaternion);
  renderer.clearDepth();
  renderer.render(scene3D, camLeft);

  // --- RIGHT EYE ---
  const rightX = rect.leftX + rect.w + rect.gap;
  renderer.setScissor(rightX, leftY, rect.w, rect.h);
  renderer.setViewport(rightX, leftY, rect.w, rect.h);
  renderer.clear();
  renderer.render(sceneVideo, orthoCam);
  camRight.position.set(FIXED_IPD / 2, 0, 0);
  camRight.quaternion.copy(perspectiveBase.quaternion);
  renderer.clearDepth();
  renderer.render(scene3D, camRight);

  renderer.setScissorTest(false);
}
</script>
