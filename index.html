<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Phone VR Viewer</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:#000; }
#fovSlider, #fullscreenBtn { position:absolute; z-index:10; }
#fovSlider { top:10px; left:10px; width:120px; }
#fullscreenBtn { top:10px; right:10px; font-size:16px; padding:6px 12px; }
#startBtn { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); padding:15px 25px; font-size:18px; border-radius:12px; background:#333; color:white; z-index:20; }
/* Ensure the controls are hidden until we start */
#fovSlider, #fullscreenBtn { display: none; } 
</style>
</head>
<body>
<input type="range" id="fovSlider" min="30" max="120" value="70">
<button id="fullscreenBtn">Fullscreen</button>
<button id="startBtn">Tap to Start VR</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
let renderer, scene, cameraLeft, cameraRight, plane, video, videoTexture;
let fovSlider = document.getElementById('fovSlider');
let fullscreenBtn = document.getElementById('fullscreenBtn');
let startBtn = document.getElementById('startBtn');
let fovScale = 0.7;
let menuVisible = false;

// --- GLOBALS FOR INTERACTION ---
let cursorMesh;
let menuButtonMesh; 
let interactiveObjects = []; 
const raycaster = new THREE.Raycaster();
const cursorPosition = new THREE.Vector2(0, 0); 
let INTERSECTED = null; 
// --- END GLOBALS ---


startBtn.addEventListener('click', async () => {
  // Request fullscreen and camera access at the same time for better compatibility
  if(document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  }
  
  startBtn.style.display = 'none';
  fullscreenBtn.style.display = 'block';
  fovSlider.style.display = 'block';

  video = document.createElement('video');
  video.autoplay = true;
  video.playsInline = true;
  video.muted = true;
  video.style.display = 'none'; // Keep the raw video element hidden
  document.body.appendChild(video);

  try {
    // Request 'environment' camera for the back camera
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
    video.srcObject = stream;
    
    // Crucial: Wait for the video to load metadata and start playing
    video.addEventListener('loadedmetadata', async () => {
        await video.play();
        initThreeJS();
    }, { once: true });
    
  } catch(e){
    alert('Camera access denied or not supported. Error: ' + e.message);
    startBtn.style.display = 'block';
  }
});

function initThreeJS(){
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  // Basic camera setup
  cameraLeft = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 1000);
  cameraRight = cameraLeft.clone();
  let baseIPD = 0.03;
  cameraLeft.position.x = -baseIPD/2;
  cameraRight.position.x = baseIPD/2;

  // Video Texture (Camera Output)
  videoTexture = new THREE.VideoTexture(video);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;

  const aspect = video.videoWidth / video.videoHeight;
  const geometry = new THREE.PlaneGeometry(aspect, 1);
  const material = new THREE.MeshBasicMaterial({ map: videoTexture, depthWrite: false });
  plane = new THREE.Mesh(geometry, material);
  plane.position.z = -2;
  scene.add(plane);

  // Example AR model
  const loader = new THREE.GLTFLoader();
  loader.load('https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf', gltf=>{
    const model = gltf.scene;
    model.position.set(0, -0.5, -1.5);
    scene.add(model);
  });
  
  // --- Gaze Cursor Setup ---
  const cursorGeometry = new THREE.RingGeometry(0.005, 0.01, 32);
  const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  cursorMesh = new THREE.Mesh(cursorGeometry, cursorMaterial);
  cursorMesh.position.set(0, 0, -1.0); // Fixed position in front of the camera
  cursorMesh.visible = false; // <<< CHANGE: START HIDDEN
  scene.add(cursorMesh);
  // --- END Gaze Cursor Setup ---

  // --- World-Locked Menu Button Setup ---
  const buttonGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.05);
  const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0x3333ff });
  
  menuButtonMesh = new THREE.Mesh(buttonGeometry, buttonMaterial);
  menuButtonMesh.position.set(0, -0.2, -1.4);
  menuButtonMesh.rotation.x = Math.PI * -0.1; 
  
  menuButtonMesh.userData = { 
      type: 'button',
      name: 'Start/Stop',
      onClick: () => {
          console.log('Menu Button Clicked! (Action Triggered)');
          menuButtonMesh.material.color.set(Math.random() * 0xffffff); 
      }
  };
  
  menuButtonMesh.visible = false; 
  scene.add(menuButtonMesh);
  interactiveObjects.push(menuButtonMesh); 
  // --- END World-Locked Menu Button Setup ---

  // Double-tap menu toggle AND Gaze-and-Tap Click
  let lastTap = 0;
  window.addEventListener('touchend', e=>{
    const now = Date.now();
    
    // Check for an interactive click first (single tap)
    if (INTERSECTED) {
        INTERSECTED.userData.onClick();
        return; 
    }

    // Original Double-tap logic: toggle menu visibility
    if(now - lastTap < 300){
      menuVisible = !menuVisible;
      
      // <<< CHANGE: Update visibility for both menu and cursor
      if(menuButtonMesh) menuButtonMesh.visible = menuVisible; 
      if(cursorMesh) cursorMesh.visible = menuVisible; 
    }
    lastTap = now;
  });

  fovSlider.addEventListener('input', ()=>{
    fovScale = fovSlider.value/100;
    plane.scale.set(fovScale,fovScale,1);
    let ipd = 0.03*fovScale;
    cameraLeft.position.x = -ipd/2;
    cameraRight.position.x = ipd/2;
  });

  fullscreenBtn.addEventListener('click', ()=>{
    if(!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
  });

  window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    cameraLeft.aspect = cameraRight.aspect = window.innerWidth/window.innerHeight;
    cameraLeft.updateProjectionMatrix();
    cameraRight.updateProjectionMatrix();
  });

  animate();
}

function animate(){
  requestAnimationFrame(animate);
  if(!renderer) return;

  // --- Raycasting Logic for Gaze Interaction ---
  if(menuVisible) { // <<< CHANGE: ONLY CHECK FOR INTERSECTIONS WHEN MENU IS ON
      raycaster.setFromCamera(cursorPosition, cameraLeft); 
      const intersects = raycaster.intersectObjects(interactiveObjects, false);

      if (intersects.length > 0) {
        const intersectedObject = intersects[0].object;
        
        if (INTERSECTED != intersectedObject) {
          if (INTERSECTED) {
            INTERSECTED.material.emissive.setHex(0x000000);
          }
          INTERSECTED = intersectedObject;
          INTERSECTED.material.emissive.setHex(0x303030); 
          cursorMesh.scale.set(1.5, 1.5, 1.5); 
        }
      } else {
        if (INTERSECTED) {
          INTERSECTED.material.emissive.setHex(0x000000);
          cursorMesh.scale.set(1, 1, 1);
        }
        INTERSECTED = null;
      }
  } else {
    // Reset intersection when menu is hidden
    if (INTERSECTED) INTERSECTED.material.emissive.setHex(0x000000);
    INTERSECTED = null;
  }
  // --- END Raycasting Logic ---

  // The video texture needs to be updated continuously
  if (video && video.readyState >= video.HAVE_ENOUGH_DATA) {
    if (videoTexture) videoTexture.needsUpdate = true;
  }

  renderer.clear();

  // Left eye
  renderer.setViewport(0,0,window.innerWidth/2,window.innerHeight);
  renderer.render(scene,cameraLeft);

  // Right eye
  renderer.setViewport(window.innerWidth/2,0,window.innerWidth/2,window.innerHeight);
  renderer.render(scene,cameraRight);
}
</script>
</body>
</html>
