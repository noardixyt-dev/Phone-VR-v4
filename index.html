<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Phone VR Viewer — improved (3DOF menu)</title>
<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #controls{position:absolute;z-index:30;left:12px;top:10px;display:flex;gap:10px;align-items:center}
  .control{background:rgba(0,0,0,0.4);backdrop-filter:blur(6px);padding:8px;border-radius:8px;font-size:13px}
  #fovSlider,#eyeAspectSlider{width:160px}
  #fullscreenBtn{position:absolute;top:10px;right:10px;z-index:30;padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.06);color:#fff;font-size:14px}
  #startBtn{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:14px 20px;border-radius:10px;background:#111;color:#fff;z-index:40;border:1px solid rgba(255,255,255,0.06);font-size:16px}
  #labelSmall{font-size:12px;opacity:0.9}
  #hint{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);font-size:12px;opacity:0.7;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,0.35);z-index:20}
  video{display:none!important;}
</style>
</head>
<body>
  <div id="controls" aria-hidden="true" style="display:none">
    <div class="control">
      <div id="labelSmall">Camera FOV <span id="fovVal">70°</span></div>
      <input id="fovSlider" type="range" min="30" max="120" value="70" />
    </div>
    <div class="control">
      <div id="labelSmall">Eye width:height <span id="eyeAspectVal">1.50</span></div>
      <input id="eyeAspectSlider" type="range" min="100" max="180" value="150" />
    </div>
  </div>

  <button id="fullscreenBtn" style="display:none">Fullscreen</button>
  <button id="startBtn">Tap to Start VR</button>
  <div id="hint">Double-tap to toggle menu • Drag to move cursor • Tap objects to click</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
/* ==== UI elements ==== */
const fovSlider = document.getElementById('fovSlider');
const fovVal = document.getElementById('fovVal');
const eyeAspectSlider = document.getElementById('eyeAspectSlider');
const eyeAspectVal = document.getElementById('eyeAspectVal');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const startBtn = document.getElementById('startBtn');
const controls = document.getElementById('controls');

let renderer, scene, cameraBase, cameraLeft, cameraRight;
let video, videoTexture, videoPlane;
let cursorMesh, menuButtonMesh;
let interactiveObjects = [];
const raycaster = new THREE.Raycaster();
const pointerNDC = new THREE.Vector2(0, 0);
let INTERSECTED = null;
let menuVisible = false;
let lastTap = 0;
const baseIPD = 0.06;
let cameraFov = parseFloat(fovSlider.value);
let eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0;
const planeDist = 1.5;

/* ==== Device Orientation (3DOF) ==== */
const zee = new THREE.Vector3(0, 0, 1);
const euler = new THREE.Euler();
const q0 = new THREE.Quaternion();
const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
let deviceQuat = new THREE.Quaternion();
let screenOrientation = 0;
let deviceOrientationEnabled = false;

function setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {
  const degToRad = Math.PI / 180;
  euler.set(beta * degToRad, alpha * degToRad, -gamma * degToRad, 'YXZ');
  quaternion.setFromEuler(euler);
  quaternion.multiply(q1);
  quaternion.multiply(q0.setFromAxisAngle(zee, -orient * degToRad));
}
function updateScreenOrientation() {
  screenOrientation = window.orientation || 0;
}
async function enableDeviceOrientation() {
  updateScreenOrientation();
  if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
    try {
      const perm = await DeviceOrientationEvent.requestPermission();
      if (perm === 'granted') {
        window.addEventListener('deviceorientation', ev => {
          deviceOrientationEnabled = true;
          setObjectQuaternion(deviceQuat, ev.alpha||0, ev.beta||0, ev.gamma||0, screenOrientation);
        }, true);
      }
    } catch (e) { console.warn(e); }
  } else {
    window.addEventListener('deviceorientation', ev => {
      deviceOrientationEnabled = true;
      setObjectQuaternion(deviceQuat, ev.alpha||0, ev.beta||0, ev.gamma||0, screenOrientation);
    }, true);
  }
}

/* ==== Start Button ==== */
startBtn.addEventListener('click', async () => {
  try { if (document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen(); } catch(e){}
  enableDeviceOrientation();
  startBtn.style.display = 'none';
  fullscreenBtn.style.display = 'block';
  controls.style.display = 'flex';
  video = document.createElement('video');
  video.setAttribute('playsinline','');
  video.autoplay = true;
  video.muted = true;
  document.body.appendChild(video);
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', async () => {
      try { await video.play(); } catch(e){ console.warn(e); }
      initThreeJS();
    }, { once:true });
  } catch (err) {
    alert('Camera access denied: ' + err.message);
    startBtn.style.display = 'block';
  }
});

fullscreenBtn.addEventListener('click', () => {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
});

/* ==== UI sliders ==== */
fovSlider.addEventListener('input', () => {
  cameraFov = parseFloat(fovSlider.value);
  fovVal.textContent = Math.round(cameraFov) + '°';
  if (cameraBase) {
    cameraBase.fov = cameraFov;
    cameraBase.updateProjectionMatrix();
    cameraLeft.fov = cameraRight.fov = cameraFov;
    cameraLeft.updateProjectionMatrix();
    cameraRight.updateProjectionMatrix();
    updateVideoPlane();
  }
});
eyeAspectSlider.addEventListener('input', () => {
  eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0;
  eyeAspectVal.textContent = eyeAspect.toFixed(2);
  if (cameraLeft) onWindowResize();
});

/* ==== ThreeJS setup ==== */
function initThreeJS() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 1);
  document.body.appendChild(renderer.domElement);
  scene = new THREE.Scene();

  cameraBase = new THREE.PerspectiveCamera(cameraFov, window.innerWidth / window.innerHeight, 0.01, 1000);
  cameraLeft = cameraBase.clone();
  cameraRight = cameraBase.clone();

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.5);
  dir.position.set(1,2,2); scene.add(dir);

  videoTexture = new THREE.VideoTexture(video);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;
  const mat = new THREE.MeshBasicMaterial({ map: videoTexture });
  const geom = new THREE.PlaneGeometry(2, 1);
  videoPlane = new THREE.Mesh(geom, mat);
  videoPlane.material.side = THREE.DoubleSide;
  scene.add(videoPlane);

  // Menu button (world anchored)
  const box = new THREE.BoxGeometry(0.36, 0.18, 0.04);
  const boxMat = new THREE.MeshStandardMaterial({ color: 0x2f7fff, emissive: 0x000000, roughness: 0.5 });
  menuButtonMesh = new THREE.Mesh(box, boxMat);
  menuButtonMesh.visible = false;
  menuButtonMesh.userData = {
    onClick: () => { menuButtonMesh.material.color.setHex(Math.random()*0xffffff); }
  };
  scene.add(menuButtonMesh);
  interactiveObjects.push(menuButtonMesh);

  const cursorGeo = new THREE.RingGeometry(0.01, 0.02, 24);
  const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
  cursorMesh.visible = false;
  scene.add(cursorMesh);

  updateVideoPlane();
  onWindowResize();
  window.addEventListener('resize', onWindowResize);

  // Pointer + double tap
  window.addEventListener('pointermove', ev => {
    pointerNDC.x = (ev.clientX / window.innerWidth) * 2 - 1;
    pointerNDC.y = -(ev.clientY / window.innerHeight) * 2 + 1;
  });
  window.addEventListener('pointerdown', ev => {
    const now = Date.now();
    if (now - lastTap < 300) {
      menuVisible = !menuVisible;
      if (menuVisible) {
        const camPos = new THREE.Vector3(); cameraBase.getWorldPosition(camPos);
        const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(cameraBase.quaternion);
        const menuPos = camPos.clone().add(camDir.multiplyScalar(1.4));
        menuButtonMesh.position.copy(menuPos);
        menuButtonMesh.quaternion.copy(cameraBase.quaternion);
        menuButtonMesh.visible = true;
        cursorMesh.visible = true;
      } else {
        menuButtonMesh.visible = false;
        cursorMesh.visible = false;
      }
    }
    lastTap = now;
  });
  window.addEventListener('click', () => {
    updateRaycasterFromNDC(pointerNDC, cameraLeft);
    const hit = raycaster.intersectObjects(interactiveObjects);
    if (hit.length > 0 && hit[0].object.userData.onClick) hit[0].object.userData.onClick();
  });

  animate();
}

/* ==== Video plane ==== */
function updateVideoPlane() {
  if (!video || !video.videoWidth) return;
  const fovRad = THREE.MathUtils.degToRad(cameraBase.fov);
  const height = 2 * Math.tan(fovRad / 2) * planeDist;
  const aspect = video.videoWidth / video.videoHeight;
  const width = height * aspect;
  videoPlane.geometry.dispose();
  videoPlane.geometry = new THREE.PlaneGeometry(width, height);
  const camPos = new THREE.Vector3(); cameraBase.getWorldPosition(camPos);
  const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(cameraBase.quaternion);
  const planePos = camPos.clone().add(camDir.multiplyScalar(planeDist));
  videoPlane.position.copy(planePos);
  videoPlane.quaternion.copy(cameraBase.quaternion);
}

function updateRaycasterFromNDC(ndc, cam){ raycaster.setFromCamera(ndc, cam); }

let cachedView={};
function computeViewports(){
  let eyeH=window.innerHeight, eyeW=Math.round(eyeH*eyeAspect);
  let totalW=eyeW*2;
  if(totalW>window.innerWidth){const s=window.innerWidth/totalW;eyeW=Math.floor(eyeW*s);eyeH=Math.floor(eyeH*s);totalW=eyeW*2;}
  const leftX=Math.floor((window.innerWidth-totalW)/2);
  cachedView={leftX,leftW:eyeW,rightX:leftX+eyeW,rightW:eyeW,eyeW,eyeH};
  return cachedView;
}
function onWindowResize(){
  if(!renderer)return;
  renderer.setSize(window.innerWidth,window.innerHeight);
  const v=computeViewports();
  cameraLeft.aspect=v.leftW/v.eyeH; cameraRight.aspect=v.rightW/v.eyeH;
  cameraLeft.updateProjectionMatrix(); cameraRight.updateProjectionMatrix();
  cameraBase.aspect=window.innerWidth/window.innerHeight; cameraBase.updateProjectionMatrix();
  updateVideoPlane();
}

/* ==== Render loop ==== */
function animate(){
  requestAnimationFrame(animate);
  if(deviceOrientationEnabled){ cameraBase.quaternion.copy(deviceQuat); }

  if(video && video.readyState>=video.HAVE_ENOUGH_DATA){ videoTexture.needsUpdate=true; }

  const ndc = pointerNDC.clone();
  const cursorDist = 1.2;
  updateRaycasterFromNDC(ndc, cameraLeft);
  const origin=raycaster.ray.origin.clone();
  const dir=raycaster.ray.direction.clone();
  const worldCursor=origin.clone().add(dir.multiplyScalar(cursorDist));
  cursorMesh.position.copy(worldCursor);
  cursorMesh.lookAt(cameraLeft.getWorldPosition(new THREE.Vector3()));
  cursorMesh.scale.setScalar(cursorDist*0.02);

  // highlight intersections
  if(menuVisible){
    const hits=raycaster.intersectObjects(interactiveObjects);
    if(hits.length>0){
      const obj=hits[0].object;
      if(INTERSECTED!==obj){
        if(INTERSECTED) INTERSECTED.material.emissive.setHex(0x000000);
        INTERSECTED=obj;
        if(INTERSECTED.material.emissive) INTERSECTED.material.emissive.setHex(0x303030);
      }
    } else if(INTERSECTED){ INTERSECTED.material.emissive.setHex(0x000000); INTERSECTED=null; }
  }

  const ipd = baseIPD * (1 + (cameraFov - 70)/400);
  cameraLeft.position.set(-ipd/2,0,0);
  cameraRight.position.set(ipd/2,0,0);
  cameraLeft.quaternion.copy(cameraBase.quaternion);
  cameraRight.quaternion.copy(cameraBase.quaternion);

  renderer.clear();
  const v=cachedView;
  renderer.setViewport(v.leftX,0,v.leftW,v.eyeH);
  renderer.setScissor(v.leftX,0,v.leftW,v.eyeH);
  renderer.setScissorTest(true);
  renderer.render(scene,cameraLeft);

  renderer.setViewport(v.rightX,0,v.rightW,v.eyeH);
  renderer.setScissor(v.rightX,0,v.rightW,v.eyeH);
  renderer.setScissorTest(true);
  renderer.render(scene,cameraRight);
  renderer.setScissorTest(false);
}
  </script>
</body>
</html>
