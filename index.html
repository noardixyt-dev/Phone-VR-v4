<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="VR Viewer" />
  <title>Phone VR Viewer By Noardix</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    #landscapeWarning {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-direction: column;
      gap: 20px;
      text-align: center;
      padding: 20px;
    }

    #landscapeWarning.hidden {
      display: none;
    }

    #landscapeWarning h1 {
      font-size: 24px;
      margin: 0;
    }

    #landscapeWarning p {
      font-size: 16px;
      opacity: 0.8;
      margin: 0;
    }

    #controls {
      position: absolute;
      z-index: 30;
      left: 12px;
      top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .control {
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(6px);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #fovSlider, #eyeAspectSlider {
      width: 120px;
      vertical-align: middle;
    }

    #fullscreenBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 30;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #fff;
      font-size: 12px;
      cursor: pointer;
    }

    #startBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 20px;
      border-radius: 10px;
      background: rgba(17, 17, 17, 0.95);
      color: #fff;
      z-index: 40;
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 16px;
      cursor: pointer;
    }

    #labelSmall {
      font-size: 11px;
      opacity: 0.9;
      margin-bottom: 4px;
    }

    #hint {
      position: absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      font-size: 11px;
      opacity: 0.6;
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.5);
      z-index: 20;
    }

    video {
      display: none !important;
    }

    #gyroStatus {
      position: absolute;
      bottom: 50px;
      left: 12px;
      z-index: 25;
      font-size: 11px;
      opacity: 0.6;
      background: rgba(0, 0, 0, 0.4);
      padding: 6px 10px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div id="landscapeWarning">
    <h1>ðŸ“± Rotate to Landscape</h1>
    <p>This VR viewer requires landscape orientation</p>
  </div>

  <div id="controls" style="display:none">
    <div class="control">
      <div id="labelSmall">FOV <span id="fovVal">70Â°</span></div>
      <input id="fovSlider" type="range" min="30" max="120" value="70" />
    </div>
    <div class="control">
      <div id="labelSmall">Eye Ratio <span id="eyeAspectVal">1.50</span></div>
      <input id="eyeAspectSlider" type="range" min="100" max="180" value="150" />
    </div>
  </div>

  <button id="fullscreenBtn" style="display:none">Fullscreen</button>
  <button id="startBtn">Tap to Start VR</button>
  <div id="hint">Double-tap to toggle menu â€¢ Gyro tracks head</div>
  <div id="gyroStatus">Gyro: Waiting...</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    /* ========== LANDSCAPE ORIENTATION CHECK ========== */
    const landscapeWarning = document.getElementById('landscapeWarning');
    const controls = document.getElementById('controls');
    const hint = document.getElementById('hint');
    const startBtn = document.getElementById('startBtn');
    const gyroStatus = document.getElementById('gyroStatus');

    function checkOrientation() {
      const isLandscape = window.innerWidth > window.innerHeight;
      if (!isLandscape) {
        landscapeWarning.classList.remove('hidden');
        controls.style.display = 'none';
        hint.style.display = 'none';
        startBtn.style.display = 'none';
        gyroStatus.style.display = 'none';
      } else {
        landscapeWarning.classList.add('hidden');
        if (renderer) {
          controls.style.display = 'flex';
          hint.style.display = 'block';
          gyroStatus.style.display = 'block';
        }
      }
    }

    window.addEventListener('orientationchange', checkOrientation);
    window.addEventListener('resize', checkOrientation);
    checkOrientation();

    /* ========== UI ELEMENTS ========== */
    const fovSlider = document.getElementById('fovSlider');
    const fovVal = document.getElementById('fovVal');
    const eyeAspectSlider = document.getElementById('eyeAspectSlider');
    const eyeAspectVal = document.getElementById('eyeAspectVal');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    /* ========== THREE.JS VARIABLES ========== */
    let renderer, scene, cameraBase, cameraLeft, cameraRight;
    let video, videoTexture, videoPlane;
    let cursorMesh, menuPanelGroup;
    let interactiveObjects = [];

    const raycaster = new THREE.Raycaster();
    let INTERSECTED = null;
    let menuVisible = false;
    let lastTap = 0;

    const baseIPD = 0.06;
    let cameraFov = parseFloat(fovSlider.value);
    let eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0;
    const planeDist = 1.5;

    /* ========== GYROSCOPE TRACKING ========== */
    let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let gyroAvailable = false;
    let gyroPermissionGranted = false;

    async function requestGyroPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission === 'granted') {
            gyroPermissionGranted = true;
            initDeviceOrientation();
            gyroStatus.textContent = 'Gyro: Active';
          } else {
            gyroStatus.textContent = 'Gyro: Denied';
          }
        } catch (error) {
          console.error('Gyro permission error:', error);
          gyroStatus.textContent = 'Gyro: Error';
        }
      } else {
        // Non-iOS or older devices
        initDeviceOrientation();
        gyroStatus.textContent = 'Gyro: Legacy Mode';
      }
    }

    function initDeviceOrientation() {
      window.addEventListener('deviceorientation', (event) => {
        deviceOrientation.alpha = THREE.MathUtils.degToRad(event.alpha || 0);
        deviceOrientation.beta = THREE.MathUtils.degToRad(event.beta || 0);
        deviceOrientation.gamma = THREE.MathUtils.degToRad(event.gamma || 0);
        gyroAvailable = true;
      });
    }

    function applyGyroRotation() {
      if (!gyroAvailable || !cameraBase) return;

      // Create Euler rotation from device orientation
      // Alpha: Z axis (yaw)
      // Beta: X axis (pitch)
      // Gamma: Y axis (roll)
      const euler = new THREE.Euler(
        deviceOrientation.beta,
        deviceOrientation.alpha,
        -deviceOrientation.gamma,
        'YXZ'
      );

      cameraBase.quaternion.setFromEuler(euler);
    }

    /* ========== START VR ========== */
    startBtn.addEventListener('click', async () => {
      if (!(window.innerWidth > window.innerHeight)) {
        alert('Please rotate to landscape');
        return;
      }

      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen().catch(e => console.log('Fullscreen denied'));
        }
      } catch (e) { /* ignore */ }

      startBtn.style.display = 'none';
      fullscreenBtn.style.display = 'block';
      controls.style.display = 'flex';
      gyroStatus.style.display = 'block';

      video = document.createElement('video');
      video.setAttribute('playsinline', '');
      video.setAttribute('webkit-playsinline', '');
      video.autoplay = true;
      video.muted = true;
      document.body.appendChild(video);

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        video.srcObject = stream;

        video.addEventListener('loadedmetadata', async () => {
          console.log('Video loaded:', video.videoWidth, 'x', video.videoHeight);
          try {
            await video.play();
          } catch (e) {
            console.warn('Play blocked:', e);
          }
          initThreeJS();
          await requestGyroPermission();
        }, { once: true });
      } catch (err) {
        alert('Camera access denied: ' + (err.message || err));
        startBtn.style.display = 'block';
      }
    });

    /* ========== FULLSCREEN TOGGLE ========== */
    fullscreenBtn.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(e => console.log('Fullscreen denied'));
      } else {
        document.exitFullscreen();
      }
    });

    /* ========== FOV & EYE ASPECT CONTROLS ========== */
    fovSlider.addEventListener('input', () => {
      cameraFov = parseFloat(fovSlider.value);
      fovVal.textContent = Math.round(cameraFov) + 'Â°';
      if (cameraBase) {
        cameraBase.fov = cameraFov;
        cameraBase.updateProjectionMatrix();
        cameraLeft.fov = cameraRight.fov = cameraFov;
        cameraLeft.updateProjectionMatrix();
        cameraRight.updateProjectionMatrix();
        updateVideoPlane();
      }
    });

    eyeAspectSlider.addEventListener('input', () => {
      eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0;
      eyeAspectVal.textContent = eyeAspect.toFixed(2);
      if (cameraLeft) onWindowResize();
    });

    /* ========== THREE.JS INITIALIZATION ========== */
    function initThreeJS() {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.autoClear = true;
      renderer.setClearColor(0x000000, 1);
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();

      cameraBase = new THREE.PerspectiveCamera(
        cameraFov,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      cameraBase.position.set(0, 0, 0);

      cameraLeft = cameraBase.clone();
      cameraRight = cameraBase.clone();

      /* LIGHTING */
      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 0.5);
      dir.position.set(1, 2, 2);
      scene.add(dir);

      /* VIDEO TEXTURE & PLANE */
      videoTexture = new THREE.VideoTexture(video);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      videoTexture.format = THREE.RGBAFormat;

      const mat = new THREE.MeshBasicMaterial({
        map: videoTexture,
        toneMapped: false,
        side: THREE.DoubleSide
      });

      const geom = new THREE.PlaneGeometry(2, 1);
      videoPlane = new THREE.Mesh(geom, mat);
      videoPlane.position.set(0, 0, -planeDist);
      scene.add(videoPlane);
      console.log('Video plane added to scene');

      /* MENU PANEL GROUP (WORLD-LOCKED) */
      menuPanelGroup = new THREE.Group();
      menuPanelGroup.position.set(0, -0.3, -1.5); // Fixed world position
      menuPanelGroup.visible = false;
      scene.add(menuPanelGroup);

      const panelGeom = new THREE.PlaneGeometry(0.8, 0.5);
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a2e,
        emissive: 0x0a0a0a,
        roughness: 0.4,
        metalness: 0.1
      });
      const panelMesh = new THREE.Mesh(panelGeom, panelMat);
      panelMesh.position.z = 0.02;
      menuPanelGroup.add(panelMesh);

      /* MENU BUTTONS */
      const buttonConfigs = [
        { label: 'Settings', pos: [-0.25, 0.15, 0.03], color: 0x2f7fff },
        { label: 'Info', pos: [0, 0.15, 0.03], color: 0x7f2fff },
        { label: 'Close', pos: [0.25, 0.15, 0.03], color: 0xff2f7f }
      ];

      buttonConfigs.forEach((config) => {
        const btnGeom = new THREE.BoxGeometry(0.18, 0.08, 0.02);
        const btnMat = new THREE.MeshStandardMaterial({
          color: config.color,
          emissive: 0x000000,
          roughness: 0.5,
          metalness: 0.2
        });
        const btnMesh = new THREE.Mesh(btnGeom, btnMat);
        btnMesh.position.set(...config.pos);
        btnMesh.userData = {
          type: 'menu-button',
          label: config.label,
          originalColor: config.color,
          onClick: () => {
            console.log('Button clicked:', config.label);
            if (config.label === 'Close') {
              menuVisible = false;
              menuPanelGroup.visible = false;
            }
          }
        };
        menuPanelGroup.add(btnMesh);
        interactiveObjects.push(btnMesh);
      });

      /* CURSOR */
      const cursorGeo = new THREE.RingGeometry(0.01, 0.02, 24);
      const cursorMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      });
      cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
      cursorMesh.visible = false;
      scene.add(cursorMesh);

      updateVideoPlane();
      onWindowResize();

      window.addEventListener('resize', onWindowResize);

      /* DOUBLE-TAP FOR MENU */
      document.addEventListener('pointerdown', (ev) => {
        const now = Date.now();
        if (now - lastTap < 300) {
          menuVisible = !menuVisible;
          menuPanelGroup.visible = menuVisible;
          cursorMesh.visible = menuVisible;
          console.log('Menu toggled:', menuVisible);
        }
        lastTap = now;
      });

      /* MENU INTERACTION (CENTER GAZE) */
      document.addEventListener('click', (ev) => {
        if (!menuVisible) return;

        // Raycast from center of screen (0, 0 NDC)
        raycaster.setFromCamera(new THREE.Vector2(0, 0), cameraLeft);
        const intersects = raycaster.intersectObjects(menuPanelGroup.children, true);

        if (intersects.length > 0 && intersects[0].object.userData && typeof intersects[0].object.userData.onClick === 'function') {
          intersects[0].object.userData.onClick();
        }
      });

      animate();
    }

    /* ========== UPDATE VIDEO PLANE ========== */
    function updateVideoPlane() {
      if (!video || !video.videoWidth) return;

      const fovRad = THREE.MathUtils.degToRad(cameraBase.fov);
      const height = 2 * Math.tan(fovRad / 2) * planeDist;
      const videoAspect = video.videoWidth / video.videoHeight;
      const width = height * videoAspect;

      videoPlane.geometry.dispose();
      videoPlane.geometry = new THREE.PlaneGeometry(width, height);
    }

    /* ========== VIEWPORT COMPUTATION ========== */
    let cachedView = { leftX: 0, leftW: 0, rightX: 0, rightW: 0, eyeW: 0, eyeH: 0 };

    function computeViewports() {
      let eyeH = window.innerHeight;
      let eyeW = Math.round(eyeH * eyeAspect);
      let totalW = eyeW * 2;

      if (totalW > window.innerWidth) {
        const scale = window.innerWidth / totalW;
        eyeW = Math.floor(eyeW * scale);
        eyeH = Math.floor(eyeH * scale);
        totalW = eyeW * 2;
      }

      const leftX = Math.floor((window.innerWidth - totalW) / 2);
      const rightX = leftX + eyeW;

      cachedView = { leftX, leftW: eyeW, rightX, rightW: eyeW, eyeW, eyeH };
      return cachedView;
    }

    /* ========== WINDOW RESIZE ========== */
    function onWindowResize() {
      if (!renderer) return;

      renderer.setSize(window.innerWidth, window.innerHeight);

      const v = computeViewports();
      cameraLeft.aspect = v.leftW / v.eyeH;
      cameraRight.aspect = v.rightW / v.eyeH;
      cameraLeft.updateProjectionMatrix();
      cameraRight.updateProjectionMatrix();

      cameraBase.aspect = window.innerWidth / window.innerHeight;
      cameraBase.updateProjectionMatrix();

      updateVideoPlane();
    }

    /* ========== ANIMATION LOOP ========== */
    function animate() {
      requestAnimationFrame(animate);
      if (!renderer) return;

      /* UPDATE VIDEO TEXTURE */
      if (video && video.readyState >= video.HAVE_ENOUGH_DATA) {
        if (videoTexture) videoTexture.needsUpdate = true;
      }

      /* APPLY GYROSCOPE ROTATION */
      applyGyroRotation();

      /* CURSOR AT CENTER (GAZE) */
      const cursorDist = 1.2;
      raycaster.setFromCamera(new THREE.Vector2(0, 0), cameraLeft);
      const origin = raycaster.ray.origin.clone();
      const dir = raycaster.ray.direction.clone();
      const worldCursor = origin.clone().add(dir.multiplyScalar(cursorDist));

      cursorMesh.position.copy(worldCursor);
      cursorMesh.lookAt(cameraLeft.getWorldPosition(new THREE.Vector3()));
      cursorMesh.scale.setScalar(cursorDist * 0.02);

      /* MENU HOVER DETECTION */
      if (menuVisible) {
        const intersects = raycaster.intersectObjects(menuPanelGroup.children, true);
        if (intersects.length > 0) {
          const obj = intersects[0].object;
          if (INTERSECTED !== obj) {
            if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
              INTERSECTED.material.emissive.setHex(0x000000);
            }
            INTERSECTED = obj;
            if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
              INTERSECTED.material.emissive.setHex(0x505050);
            }
            cursorMesh.scale.multiplyScalar(2.0);
          }
        } else {
          if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
            INTERSECTED.material.emissive.setHex(0x000000);
          }
          INTERSECTED = null;
          cursorMesh.scale.setScalar(cursorDist * 0.02);
        }
      } else {
        if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
          INTERSECTED.material.emissive.setHex(0x000000);
        }
        INTERSECTED = null;
      }

      /* STEREO RENDERING */
      const ipd = baseIPD * (1 + (cameraFov - 70) / 400);
      cameraLeft.position.set(-ipd / 2, 0, 0);
      cameraRight.position.set(ipd / 2, 0, 0);

      cameraLeft.quaternion.copy(cameraBase.quaternion);
      cameraRight.quaternion.copy(cameraBase.quaternion);

      renderer.clear();
      const v = cachedView;

      // LEFT EYE
      renderer.setViewport(v.leftX, 0, v.leftW, v.eyeH);
      renderer.setScissor(v.leftX, 0, v.leftW, v.eyeH);
      renderer.setScissorTest(true);
      renderer.render(scene, cameraLeft);

      // RIGHT EYE
      renderer.setViewport(v.rightX, 0, v.rightW, v.eyeH);
      renderer.setScissor(v.rightX, 0, v.rightW, v.eyeH);
      renderer.setScissorTest(true);
      renderer.render(scene, cameraRight);

      renderer.setScissorTest(false);
    }
  </script>
</body>
</html>
