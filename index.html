<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Phone VR Viewer — centered eyes + anchored menu</title>
<style>
  html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #controls{position:absolute;z-index:30;left:12px;top:10px;display:flex;gap:10px;align-items:center}
  .control{background:rgba(0,0,0,0.4);backdrop-filter:blur(6px);padding:8px;border-radius:8px;font-size:13px}
  #fovSlider{width:200px}
  #fullscreenBtn{position:absolute;top:10px;right:10px;z-index:30;padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.06);color:#fff;font-size:14px}
  #startBtn{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:14px 20px;border-radius:10px;background:#111;color:#fff;z-index:40;border:1px solid rgba(255,255,255,0.06);font-size:16px}
  #labelSmall{font-size:12px;opacity:0.9}
  #hint{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);font-size:12px;opacity:0.7;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,0.35);z-index:20}
  video{display:none!important;}
</style>
</head>
<body>
  <div id="controls" aria-hidden="true" style="display:none">
    <div class="control">
      <div id="labelSmall">FOV (eye window size) <span id="fovVal">70%</span></div>
      <input id="fovSlider" type="range" min="40" max="100" value="70" />
    </div>
  </div>

  <button id="fullscreenBtn" style="display:none">Fullscreen</button>
  <button id="startBtn">Tap to Start VR</button>
  <div id="hint">Double-tap to toggle menu • Drag to move cursor • Tap objects to click</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>

  <script>
/* --- UI --- */
const fovSlider = document.getElementById('fovSlider');
const fovVal = document.getElementById('fovVal');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const startBtn = document.getElementById('startBtn');
const controls = document.getElementById('controls');

let renderer, scene, cameraBase, cameraLeft, cameraRight;
let video, videoTexture, videoPlane;
let cursorMesh, menuButtonMesh;
let interactiveObjects = [];
const raycaster = new THREE.Raycaster();
const pointerNDC = new THREE.Vector2(0,0);
let INTERSECTED = null;
let menuVisible = false;
let lastTap = 0;

/* fixed IPD in meters (this is fixed — user cannot change) */
const FIXED_IPD = 0.064; // 64 mm typical interpupillary distance scaled
/* how far to place the video plane from camera */
const planeDist = 1.5;

/* eye viewport scale (percentage of screen height) */
let eyeScalePct = parseFloat(fovSlider.value); // 40..100
fovVal.textContent = Math.round(eyeScalePct) + '%';

/* --- Device orientation (3DOF) helpers --- */
const zee = new THREE.Vector3(0, 0, 1);
const euler = new THREE.Euler();
const q0 = new THREE.Quaternion();
const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
let deviceQuat = new THREE.Quaternion();
let deviceOrientationEnabled = false;
function setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {
  const degToRad = Math.PI / 180;
  euler.set(beta * degToRad, alpha * degToRad, -gamma * degToRad, 'YXZ');
  quaternion.setFromEuler(euler);
  quaternion.multiply(q1);
  quaternion.multiply(q0.setFromAxisAngle(zee, - orient * degToRad));
}
function updateScreenOrientation() {
  // fallback; many browsers expose window.orientation
  return window.orientation || 0;
}
async function enableDeviceOrientation() {
  const orient = updateScreenOrientation();
  if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
    try {
      const perm = await DeviceOrientationEvent.requestPermission();
      if (perm === 'granted') {
        window.addEventListener('deviceorientation', ev => {
          deviceOrientationEnabled = true;
          setObjectQuaternion(deviceQuat, ev.alpha||0, ev.beta||0, ev.gamma||0, orient);
        }, true);
      }
    } catch (e) { console.warn('deviceorientation permission failed', e); }
  } else {
    window.addEventListener('deviceorientation', ev => {
      deviceOrientationEnabled = true;
      setObjectQuaternion(deviceQuat, ev.alpha||0, ev.beta||0, ev.gamma||0, orient);
    }, true);
  }
}

/* --- Start & camera access --- */
startBtn.addEventListener('click', async () => {
  try { if (document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen(); } catch(e){}
  enableDeviceOrientation();
  startBtn.style.display = 'none';
  fullscreenBtn.style.display = 'block';
  controls.style.display = 'flex';

  video = document.createElement('video');
  video.setAttribute('playsinline','');
  video.autoplay = true;
  video.muted = true;
  document.body.appendChild(video);

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', async () => {
      try { await video.play(); } catch(e){ console.warn('video.play blocked', e); }
      initThree();
    }, { once:true });
  } catch (err) {
    alert('Camera access denied or not available: ' + (err && err.message ? err.message : err));
    startBtn.style.display = 'block';
  }
});

/* fullscreen toggle */
fullscreenBtn.addEventListener('click', () => {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
});

/* fov slider now controls window size (scale of eyes) */
fovSlider.addEventListener('input', () => {
  eyeScalePct = parseFloat(fovSlider.value);
  fovVal.textContent = Math.round(eyeScalePct) + '%';
  if (renderer) onWindowResize();
});

/* --- Three init --- */
function initThree() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = true;
  renderer.setClearColor(0x000000, 1);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  // Use a reasonable camera FOV for projection (keeps perspective look)
  cameraBase = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
  cameraBase.position.set(0,0,0);
  cameraLeft = cameraBase.clone();
  cameraRight = cameraBase.clone();

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.5); dir.position.set(1,2,2); scene.add(dir);

  // video texture and plane
  videoTexture = new THREE.VideoTexture(video);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;
  const mat = new THREE.MeshBasicMaterial({ map: videoTexture, toneMapped: false });
  const geom = new THREE.PlaneGeometry(2,1);
  videoPlane = new THREE.Mesh(geom, mat);
  videoPlane.material.side = THREE.DoubleSide;
  scene.add(videoPlane);

  // world anchored menu button
  const box = new THREE.BoxGeometry(0.36, 0.18, 0.04);
  const boxMat = new THREE.MeshStandardMaterial({ color: 0x2f7fff, emissive: 0x000000, roughness: 0.5, metalness: 0.1 });
  menuButtonMesh = new THREE.Mesh(box, boxMat);
  menuButtonMesh.visible = false;
  menuButtonMesh.userData = {
    onClick: () => { menuButtonMesh.material.color.setHex(Math.floor(Math.random()*0xffffff)); }
  };
  scene.add(menuButtonMesh);
  interactiveObjects.push(menuButtonMesh);

  // cursor
  const cursorGeo = new THREE.RingGeometry(0.01, 0.02, 24);
  const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
  cursorMesh.visible = false;
  scene.add(cursorMesh);

  updateVideoPlane();
  onWindowResize();
  window.addEventListener('resize', onWindowResize);

  // pointer events
  window.addEventListener('pointermove', (ev) => {
    pointerNDC.x = (ev.clientX / window.innerWidth) * 2 - 1;
    pointerNDC.y = -(ev.clientY / window.innerHeight) * 2 + 1;
  }, { passive:true });

  window.addEventListener('pointerdown', (ev) => {
    const now = Date.now();
    if (now - lastTap < 300) {
      // double-tap: toggle menu anchored at gaze location
      menuVisible = !menuVisible;
      if (menuVisible) {
        // place menu in front of camera along gaze direction (so vertical look changes spawn position)
        const camWorldPos = new THREE.Vector3(); cameraBase.getWorldPosition(camWorldPos);
        const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(cameraBase.quaternion);
        const placeDist = 1.4; // 1.4 meters in front
        const menuPos = camWorldPos.clone().add(camDir.multiplyScalar(placeDist));
        menuButtonMesh.position.copy(menuPos);
        // orient to face the camera direction (but stay world anchored)
        menuButtonMesh.lookAt(camWorldPos);
        menuButtonMesh.visible = true;
        cursorMesh.visible = true;
      } else {
        menuButtonMesh.visible = false;
        cursorMesh.visible = false;
      }
    }
    lastTap = now;
  });

  window.addEventListener('click', (ev) => {
    // click triggers raycast against interactive objects
    updateRaycasterFromNDC(pointerNDC, cameraLeft);
    const intersects = raycaster.intersectObjects(interactiveObjects, true);
    if (intersects.length > 0 && intersects[0].object.userData && typeof intersects[0].object.userData.onClick === 'function') {
      intersects[0].object.userData.onClick();
    }
  });

  animate();
}

/* compute video plane to be at fixed planeDist in front of camera, sized to video aspect */
function updateVideoPlane() {
  if (!video || !video.videoWidth) return;
  const fovRad = THREE.MathUtils.degToRad(cameraBase.fov);
  const height = 2 * Math.tan(fovRad / 2) * planeDist;
  const videoAspect = video.videoWidth / video.videoHeight;
  const width = height * videoAspect;
  if (videoPlane.geometry) videoPlane.geometry.dispose();
  videoPlane.geometry = new THREE.PlaneGeometry(width, height);
  const camWorldPos = new THREE.Vector3(); cameraBase.getWorldPosition(camWorldPos);
  const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(cameraBase.quaternion);
  const planePos = camWorldPos.clone().add(camDir.clone().multiplyScalar(planeDist));
  videoPlane.position.copy(planePos);
  videoPlane.quaternion.copy(cameraBase.quaternion);
}

/* Raycaster helper */
function updateRaycasterFromNDC(ndc, cam) {
  raycaster.setFromCamera(ndc, cam);
}

/* ---- Viewport computation
   - eyeScalePct controls the height of the eye windows as percentage of screen height
   - eyes are centered vertically and horizontally (with small gap)
   - video aspect used to compute reasonable eye width; clamped to fit screen
*/
let cachedView = { leftX:0, leftY:0, leftW:0, leftH:0, rightX:0, rightY:0, rightW:0, rightH:0, gap:8 };
function computeViewports() {
  const gap = 8; // pixels between eyes
  const scale = Math.max(0.4, Math.min(1.0, eyeScalePct / 100)); // clamp 0.4..1.0
  // desired eye height in pixels
  let eyeH = Math.round(window.innerHeight * scale);
  // approximate video aspect (fallback)
  const vAspect = (video && video.videoWidth) ? (video.videoWidth / video.videoHeight) : (16/9);
  // desired eye width from video aspect
  let eyeW = Math.floor(eyeH * vAspect);
  // ensure both eyes + gap fit horizontally
  if (eyeW * 2 + gap > window.innerWidth) {
    const avail = window.innerWidth - gap;
    eyeW = Math.floor(avail / 2);
    eyeH = Math.floor(eyeW / vAspect);
  }
  // center horizontally and vertically
  const totalW = eyeW * 2 + gap;
  const leftX = Math.floor((window.innerWidth - totalW) / 2);
  const rightX = leftX + eyeW + gap;
  const topY = Math.floor((window.innerHeight - eyeH) / 2); // vertically centered
  cachedView = {
    leftX, leftY: topY, leftW: eyeW, leftH: eyeH,
    rightX, rightY: topY, rightW: eyeW, rightH: eyeH,
    gap
  };
  return cachedView;
}

/* window resize */
function onWindowResize() {
  if (!renderer) return;
  renderer.setSize(window.innerWidth, window.innerHeight);
  computeViewports();
  // update camera projection aspect using per-eye viewport aspect
  const v = cachedView;
  cameraLeft.aspect = v.leftW / v.leftH;
  cameraRight.aspect = v.rightW / v.rightH;
  cameraLeft.updateProjectionMatrix();
  cameraRight.updateProjectionMatrix();
  cameraBase.aspect = window.innerWidth / window.innerHeight;
  cameraBase.updateProjectionMatrix();
  updateVideoPlane();
}

/* render loop */
function animate() {
  requestAnimationFrame(animate);
  if (!renderer) return;

  // apply device orientation to base camera if available (3-DOF)
  if (deviceOrientationEnabled) {
    cameraBase.quaternion.copy(deviceQuat);
  }

  // keep video texture fresh
  if (video && video.readyState >= video.HAVE_ENOUGH_DATA) {
    if (videoTexture) videoTexture.needsUpdate = true;
  }

  // cursor placement from pointer (or center)
  const ndc = pointerNDC.clone();
  // default center if untouched (pointerNDC initialized to 0,0)
  const cursorDist = 1.2;
  updateRaycasterFromNDC(ndc, cameraLeft);
  const origin = raycaster.ray.origin.clone();
  const dir = raycaster.ray.direction.clone();
  const worldCursor = origin.clone().add(dir.multiplyScalar(cursorDist));
  cursorMesh.position.copy(worldCursor);
  cursorMesh.lookAt(cameraLeft.getWorldPosition(new THREE.Vector3()));
  cursorMesh.scale.setScalar(cursorDist * 0.02);

  // highlight intersections when menu visible
  if (menuVisible) {
    const intersects = raycaster.intersectObjects(interactiveObjects, false);
    if (intersects.length > 0) {
      const obj = intersects[0].object;
      if (INTERSECTED !== obj) {
        if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x000000);
        INTERSECTED = obj;
        if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x303030);
        cursorMesh.scale.multiplyScalar(1.6);
      }
    } else {
      if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x000000);
      INTERSECTED = null;
      cursorMesh.scale.setScalar(cursorDist * 0.02);
    }
  } else {
    if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) INTERSECTED.material.emissive.setHex(0x000000);
    INTERSECTED = null;
  }

  // fixed IPD applied to left/right cameras
  const ipd = FIXED_IPD;
  cameraLeft.position.set(-ipd/2, 0, 0);
  cameraRight.position.set(ipd/2, 0, 0);
  cameraLeft.quaternion.copy(cameraBase.quaternion);
  cameraRight.quaternion.copy(cameraBase.quaternion);

  renderer.clear();

  // compute or reuse viewports
  const v = cachedView.leftW ? cachedView : computeViewports();

  // left eye: use cached leftX/leftY/leftW/leftH (note Y origin at bottom for gl viewports)
  renderer.setViewport(v.leftX, window.innerHeight - v.leftY - v.leftH, v.leftW, v.leftH);
  renderer.setScissor(v.leftX, window.innerHeight - v.leftY - v.leftH, v.leftW, v.leftH);
  renderer.setScissorTest(true);
  renderer.render(scene, cameraLeft);

  // right eye
  renderer.setViewport(v.rightX, window.innerHeight - v.rightY - v.rightH, v.rightW, v.rightH);
  renderer.setScissor(v.rightX, window.innerHeight - v.rightY - v.rightH, v.rightW, v.rightH);
  renderer.setScissorTest(true);
  renderer.render(scene, cameraRight);

  renderer.setScissorTest(false);
}

/* initial compute */
computeViewports();
window.addEventListener('resize', onWindowResize);
  </script>
</body>
</html>
