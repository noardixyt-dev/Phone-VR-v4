<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
  <title>Phone VR Viewer — improved</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial;
    }
    #controls {
      position: absolute;
      z-index: 30;
      left: 12px;
      top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .control {
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(6px);
      padding: 8px;
      border-radius: 8px;
      font-size: 13px;
    }
    #fovSlider, #eyeAspectSlider {
      width: 160px;
    }
    #fullscreenBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 30;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.06);
      color: #fff;
      font-size: 14px;
    }
    #startBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 20px;
      border-radius: 10px;
      background: #111;
      color: #fff;
      z-index: 40;
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 16px;
    }
    #labelSmall {
      font-size: 12px;
      opacity: 0.9;
    }
    #hint {
      position: absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      font-size: 12px;
      opacity: 0.7;
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.35);
      z-index: 20;
    }
    video {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="controls" aria-hidden="true" style="display:none">
    <div class="control">
      <div id="labelSmall">Camera FOV <span id="fovVal">70°</span></div>
      <input id="fovSlider" type="range" min="30" max="120" value="70" />
    </div>
    <div class="control">
      <div id="labelSmall">Eye width:height <span id="eyeAspectVal">1.50</span></div>
      <input id="eyeAspectSlider" type="range" min="100" max="180" value="150" />
    </div>
  </div>
  <button id="fullscreenBtn" style="display:none">Fullscreen</button>
  <button id="startBtn">Tap to Start VR</button>
  <div id="hint">Double-tap to toggle menu • Drag to move cursor • Tap objects to click</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    /* UI elements */
    const fovSlider = document.getElementById('fovSlider');
    const fovVal = document.getElementById('fovVal');
    const eyeAspectSlider = document.getElementById('eyeAspectSlider');
    const eyeAspectVal = document.getElementById('eyeAspectVal');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const startBtn = document.getElementById('startBtn');
    const controls = document.getElementById('controls');

    let renderer, scene, cameraBase, cameraLeft, cameraRight;
    let video, videoTexture, videoPlane;
    let cursorMesh, menuPanelGroup;
    let interactiveObjects = [];
    const raycaster = new THREE.Raycaster();
    const pointerNDC = new THREE.Vector2(0, 0);
    let INTERSECTED = null;
    let menuVisible = false;
    let lastTap = 0;

    const baseIPD = 0.06;
    let cameraFov = parseFloat(fovSlider.value);
    let eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0;
    const planeDist = 1.5;

    /* PATCH: Track orientation changes */
    let currentOrientation = 'portrait';
    let isLandscape = window.innerWidth > window.innerHeight;

    /* Start / camera access */
    startBtn.addEventListener('click', async () => {
      try {
        if (document.documentElement.requestFullscreen) {
          await document.documentElement.requestFullscreen();
        }
      } catch (e) { /* ignore */ }

      startBtn.style.display = 'none';
      fullscreenBtn.style.display = 'block';
      controls.style.display = 'flex';

      /* PATCH: Create video element with explicit attributes */
      video = document.createElement('video');
      video.setAttribute('playsinline', '');
      video.setAttribute('webkit-playsinline', '');
      video.autoplay = true;
      video.muted = true;
      video.style.width = '100%';
      video.style.height = '100%';
      video.style.objectFit = 'cover';
      document.body.appendChild(video);

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        video.srcObject = stream;

        video.addEventListener('loadedmetadata', async () => {
          console.log('Video metadata loaded. Dimensions:', video.videoWidth, 'x', video.videoHeight);
          try {
            await video.play();
            console.log('Video playback started');
          } catch (e) {
            console.warn('video.play blocked', e);
          }
          initThreeJS();
        }, { once: true });

        video.addEventListener('playing', () => {
          console.log('Video is now playing');
        });
      } catch (err) {
        alert('Camera access denied or not available: ' + (err && err.message ? err.message : err));
        startBtn.style.display = 'block';
      }
    });

    /* Fullscreen toggle */
    fullscreenBtn.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });

    /* UI updates */
    fovSlider.addEventListener('input', () => {
      cameraFov = parseFloat(fovSlider.value);
      fovVal.textContent = Math.round(cameraFov) + '°';
      if (cameraBase) {
        cameraBase.fov = cameraFov;
        cameraBase.updateProjectionMatrix();
        cameraLeft.fov = cameraRight.fov = cameraFov;
        cameraLeft.updateProjectionMatrix();
        cameraRight.updateProjectionMatrix();
        updateVideoPlane();
      }
    });

    eyeAspectSlider.addEventListener('input', () => {
      eyeAspect = parseFloat(eyeAspectSlider.value) / 100.0;
      eyeAspectVal.textContent = eyeAspect.toFixed(2);
      if (cameraLeft) onWindowResize();
    });

    /* PATCH: Handle orientation changes */
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        isLandscape = window.innerWidth > window.innerHeight;
        console.log('Orientation changed. Landscape:', isLandscape);
        onWindowResize();
      }, 100);
    });

    /* ThreeJS init */
    function initThreeJS() {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.autoClear = true;
      renderer.setClearColor(0x000000, 1);
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      cameraBase = new THREE.PerspectiveCamera(cameraFov, window.innerWidth / window.innerHeight, 0.01, 1000);
      cameraBase.position.set(0, 0, 0);
      cameraLeft = cameraBase.clone();
      cameraRight = cameraBase.clone();

      /* Lighting */
      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 0.5);
      dir.position.set(1, 2, 2);
      scene.add(dir);

      /* PATCH: Create video texture with proper settings */
      videoTexture = new THREE.VideoTexture(video);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      videoTexture.format = THREE.RGBAFormat;
      videoTexture.colorSpace = THREE.SRGBColorSpace;

      /* PATCH: Create material with double-sided rendering */
      const mat = new THREE.MeshBasicMaterial({
        map: videoTexture,
        toneMapped: false,
        side: THREE.DoubleSide
      });

      const geom = new THREE.PlaneGeometry(2, 1);
      videoPlane = new THREE.Mesh(geom, mat);
      videoPlane.position.set(0, 0, -planeDist);
      scene.add(videoPlane);

      console.log('Video plane created and added to scene');

      /* Menu panel group (world-tracked) */
      menuPanelGroup = new THREE.Group();
      menuPanelGroup.position.set(0, -0.3, -1.5);
      menuPanelGroup.visible = false;
      scene.add(menuPanelGroup);

      /* Menu background panel */
      const panelGeom = new THREE.PlaneGeometry(0.8, 0.5);
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a2e,
        emissive: 0x0a0a0a,
        roughness: 0.4,
        metalness: 0.1
      });
      const panelMesh = new THREE.Mesh(panelGeom, panelMat);
      menuPanelGroup.add(panelMesh);

      /* Menu buttons */
      const buttonConfigs = [
        { label: 'Settings', pos: [-0.25, 0.15, 0.01], color: 0x2f7fff },
        { label: 'Info', pos: [0, 0.15, 0.01], color: 0x7f2fff },
        { label: 'Close', pos: [0.25, 0.15, 0.01], color: 0xff2f7f }
      ];

      buttonConfigs.forEach((config) => {
        const btnGeom = new THREE.BoxGeometry(0.18, 0.08, 0.02);
        const btnMat = new THREE.MeshStandardMaterial({
          color: config.color,
          emissive: 0x000000,
          roughness: 0.5,
          metalness: 0.2
        });
        const btnMesh = new THREE.Mesh(btnGeom, btnMat);
        btnMesh.position.set(...config.pos);
        btnMesh.userData = {
          type: 'menu-button',
          label: config.label,
          originalColor: config.color,
          onClick: () => {
            console.log('Button clicked:', config.label);
            if (config.label === 'Close') {
              menuVisible = false;
              menuPanelGroup.visible = false;
            }
          }
        };
        menuPanelGroup.add(btnMesh);
        interactiveObjects.push(btnMesh);
      });

      /* Cursor */
      const cursorGeo = new THREE.RingGeometry(0.01, 0.02, 24);
      const cursorMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      });
      cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
      cursorMesh.visible = false;
      scene.add(cursorMesh);

      updateVideoPlane();
      onWindowResize();
      window.addEventListener('resize', onWindowResize);

      /* Pointer interactions */
      let pointerActive = false;
      window.addEventListener('pointermove', (ev) => {
        /* PATCH: Orientation-aware pointer mapping */
        let x, y;
        if (isLandscape) {
          x = (ev.clientX / window.innerWidth) * 2 - 1;
          y = -(ev.clientY / window.innerHeight) * 2 + 1;
        } else {
          x = (ev.clientX / window.innerWidth) * 2 - 1;
          y = -(ev.clientY / window.innerHeight) * 2 + 1;
        }
        pointerNDC.set(x, y);
        pointerActive = true;
      }, { passive: true });

      window.addEventListener('pointerdown', (ev) => {
        const now = Date.now();
        if (now - lastTap < 300) {
          menuVisible = !menuVisible;
          menuPanelGroup.visible = menuVisible;
          cursorMesh.visible = menuVisible;
          console.log('Menu toggled:', menuVisible);
        }
        lastTap = now;
      });

      window.addEventListener('click', (ev) => {
        updateRaycasterFromNDC(pointerNDC, cameraLeft);
        const intersects = raycaster.intersectObjects(menuPanelGroup.children, true);
        if (intersects.length > 0 && intersects[0].object.userData && typeof intersects[0].object.userData.onClick === 'function') {
          intersects[0].object.userData.onClick();
        }
      });

      animate();
    }

    /* Update video plane size */
    function updateVideoPlane() {
      if (!video || !video.videoWidth) {
        console.log('Video not ready yet');
        return;
      }

      const fovRad = THREE.MathUtils.degToRad(cameraBase.fov);
      const height = 2 * Math.tan(fovRad / 2) * planeDist;
      const videoAspect = video.videoWidth / video.videoHeight;
      const width = height * videoAspect;

      videoPlane.geometry.dispose();
      videoPlane.geometry = new THREE.PlaneGeometry(width, height);

      console.log('Video plane updated. Size:', width.toFixed(2), 'x', height.toFixed(2), 'Aspect:', videoAspect.toFixed(2));
    }

    /* Raycaster from NDC */
    function updateRaycasterFromNDC(ndc, cam) {
      raycaster.setFromCamera(ndc, cam);
    }

    /* Viewport computation */
    let cachedView = { leftX: 0, leftW: 0, rightX: 0, rightW: 0, eyeW: 0, eyeH: 0 };

    function computeViewports() {
      let eyeH = window.innerHeight;
      let eyeW = Math.round(eyeH * eyeAspect);
      let totalW = eyeW * 2;
      let scale = 1;

      if (totalW > window.innerWidth) {
        scale = window.innerWidth / totalW;
        eyeW = Math.floor(eyeW * scale);
        eyeH = Math.floor(eyeH * scale);
        totalW = eyeW * 2;
      }

      const leftX = Math.floor((window.innerWidth - totalW) / 2);
      const rightX = leftX + eyeW;

      cachedView = { leftX, leftW: eyeW, rightX, rightW: eyeW, eyeW, eyeH };
      return cachedView;
    }

    /* Handle window resize */
    function onWindowResize() {
      if (!renderer) return;

      isLandscape = window.innerWidth > window.innerHeight;
      renderer.setSize(window.innerWidth, window.innerHeight);

      const v = computeViewports();

      cameraLeft.aspect = v.leftW / v.eyeH;
      cameraRight.aspect = v.rightW / v.eyeH;
      cameraLeft.updateProjectionMatrix();
      cameraRight.updateProjectionMatrix();

      cameraBase.aspect = window.innerWidth / window.innerHeight;
      cameraBase.updateProjectionMatrix();

      updateVideoPlane();
    }

    /* Main animation loop */
    function animate() {
      requestAnimationFrame(animate);
      if (!renderer) return;

      /* PATCH: Ensure video texture updates continuously */
      if (video && video.readyState >= video.HAVE_ENOUGH_DATA) {
        if (videoTexture) {
          videoTexture.needsUpdate = true;
        }
      }

      /* Cursor positioning */
      const ndc = pointerNDC.clone();
      const cursorDist = 1.2;
      updateRaycasterFromNDC(ndc, cameraLeft);
      const origin = raycaster.ray.origin.clone();
      const dir = raycaster.ray.direction.clone();
      const worldCursor = origin.clone().add(dir.multiplyScalar(cursorDist));
      cursorMesh.position.copy(worldCursor);
      cursorMesh.lookAt(cameraLeft.getWorldPosition(new THREE.Vector3()));
      cursorMesh.scale.setScalar(cursorDist * 0.02);

      /* Menu interaction */
      if (menuVisible) {
        const intersects = raycaster.intersectObjects(menuPanelGroup.children, true);
        if (intersects.length > 0) {
          const obj = intersects[0].object;
          if (INTERSECTED !== obj) {
            if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
              INTERSECTED.material.emissive.setHex(0x000000);
            }
            INTERSECTED = obj;
            if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
              INTERSECTED.material.emissive.setHex(0x404040);
            }
            cursorMesh.scale.multiplyScalar(1.6);
          }
        } else {
          if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
            INTERSECTED.material.emissive.setHex(0x000000);
          }
          INTERSECTED = null;
          cursorMesh.scale.setScalar(cursorDist * 0.02);
        }
      } else {
        if (INTERSECTED && INTERSECTED.material && 'emissive' in INTERSECTED.material) {
          INTERSECTED.material.emissive.setHex(0x000000);
        }
        INTERSECTED = null;
      }

      /* Stereo rendering */
      const ipd = baseIPD * (1 + (cameraFov - 70) / 400);
      cameraLeft.position.set(-ipd / 2, 0, 0);
      cameraRight.position.set(ipd / 2, 0, 0);
      cameraLeft.quaternion.copy(cameraBase.quaternion);
      cameraRight.quaternion.copy(cameraBase.quaternion);

      renderer.clear();
      const v = cachedView;

      /* Render left eye */
      renderer.setViewport(v.leftX, 0, v.leftW, v.eyeH);
      renderer.setScissor(v.leftX, 0, v.leftW, v.eyeH);
      renderer.setScissorTest(true);
      renderer.render(scene, cameraLeft);

      /* Render right eye */
      renderer.setViewport(v.rightX, 0, v.rightW, v.eyeH);
      renderer.setScissor(v.rightX, 0, v.rightW, v.eyeH);
      renderer.setScissorTest(true);
      renderer.render(scene, cameraRight);

      renderer.setScissorTest(false);
    }
  </script>
</body>
</html>
