<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Phone VR Viewer</title>
<style>
/* Removed the old 2D #menu styles as we are using a 3D mesh now */
html, body { margin:0; padding:0; overflow:hidden; background:#000; }
#fovSlider, #fullscreenBtn { position:absolute; z-index:10; }
#fovSlider { top:10px; left:10px; width:120px; }
#fullscreenBtn { top:10px; right:10px; font-size:16px; padding:6px 12px; }
#startBtn { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); padding:15px 25px; font-size:18px; border-radius:12px; background:#333; color:white; z-index:20; }
</style>
</head>
<body>
<input type="range" id="fovSlider" min="30" max="120" value="70">
<button id="fullscreenBtn">Fullscreen</button>
<button id="startBtn">Tap to Start VR</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
let renderer, scene, cameraLeft, cameraRight, plane, video, videoTexture;
let fovSlider = document.getElementById('fovSlider');
let fullscreenBtn = document.getElementById('fullscreenBtn');
let startBtn = document.getElementById('startBtn');
let fovScale = 0.7;
let menuVisible = false;

// --- NEW/UPDATED GLOBALS FOR INTERACTION ---
let cursorMesh;
let menuButtonMesh; // Renamed from menuMesh for clarity
let interactiveObjects = []; // Array to hold all clickable 3D objects
const raycaster = new THREE.Raycaster();
const cursorPosition = new THREE.Vector2(0, 0); // Raycaster checks from the center (0, 0)
let INTERSECTED = null; // Tracks the currently gazed-at object
// --- END NEW GLOBALS ---


startBtn.addEventListener('click', async () => {
  startBtn.style.display = 'none';
  video = document.createElement('video');
  video.autoplay = true;
  video.playsInline = true;
  video.muted = true;

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
    video.srcObject = stream;
    await video.play();
  } catch(e){
    alert('Camera access denied or not supported.');
    return;
  }

  video.addEventListener('canplay', ()=>initThreeJS());
});

function initThreeJS(){
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  cameraLeft = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 1000);
  cameraRight = cameraLeft.clone();
  let baseIPD = 0.03;
  cameraLeft.position.x = -baseIPD/2;
  cameraRight.position.x = baseIPD/2;

  videoTexture = new THREE.VideoTexture(video);
  const aspect = 1.5;
  const geometry = new THREE.PlaneGeometry(aspect,1);
  const material = new THREE.MeshBasicMaterial({ map: videoTexture });
  plane = new THREE.Mesh(geometry, material);
  plane.position.z = -2;
  plane.material.map.minFilter = THREE.LinearFilter;
  scene.add(plane);

  // Example AR model
  const loader = new THREE.GLTFLoader();
  loader.load('https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf', gltf=>{
    const model = gltf.scene;
    model.position.set(0, -0.5, -1.5);
    scene.add(model);
  });
  
  // --- NEW: Gaze Cursor Setup ---
  const cursorGeometry = new THREE.RingGeometry(0.005, 0.01, 32);
  const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  cursorMesh = new THREE.Mesh(cursorGeometry, cursorMaterial);
  cursorMesh.position.set(0, 0, -1.0); // Fixed position in front of the camera
  scene.add(cursorMesh);
  // --- END NEW: Gaze Cursor Setup ---

  // --- NEW: World-Locked Menu Button Setup ---
  const buttonGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.05); // Simple button shape
  const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0x3333ff }); // Blue button
  
  menuButtonMesh = new THREE.Mesh(buttonGeometry, buttonMaterial);
  menuButtonMesh.position.set(0, -0.2, -1.4); // Positioned in the 3D world
  menuButtonMesh.rotation.x = Math.PI * -0.1; // Tilt up slightly
  
  // Custom property to identify the action
  menuButtonMesh.userData = { 
      type: 'button',
      name: 'Start/Stop',
      onClick: () => {
          console.log('Menu Button Clicked! (Action Triggered)');
          // Example action: change the color
          menuButtonMesh.material.color.set(Math.random() * 0xffffff); 
      }
  };
  
  menuButtonMesh.visible = false; // Start hidden
  scene.add(menuButtonMesh);
  interactiveObjects.push(menuButtonMesh); // Add to the interactive list
  // --- END NEW: World-Locked Menu Button Setup ---

  // Double-tap menu toggle AND Gaze-and-Tap Click
  let lastTap = 0;
  window.addEventListener('touchend', e=>{
    const now = Date.now();
    
    // --- UPDATED: Check for an interactive click first (single tap) ---
    if (INTERSECTED) {
        // A single tap acts as a click on the gazed-at object
        INTERSECTED.userData.onClick();
        return; // Consume the tap as a click
    }
    // --- END UPDATED ---

    // Original Double-tap logic: toggle menu visibility
    if(now - lastTap < 300){
      menuVisible = !menuVisible;
      // Control the visibility of the 3D mesh
      if(menuButtonMesh) menuButtonMesh.visible = menuVisible; 
    }
    lastTap = now;
  });

  // Removed deviceorientation listener as the 3D object tracks correctly now

  fovSlider.addEventListener('input', ()=>{
    fovScale = fovSlider.value/100;
    plane.scale.set(fovScale,fovScale,1);
    let ipd = 0.03*fovScale;
    cameraLeft.position.x = -ipd/2;
    cameraRight.position.x = ipd/2;
  });

  fullscreenBtn.addEventListener('click', ()=>{
    if(!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
  });

  window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    cameraLeft.aspect = cameraRight.aspect = window.innerWidth/window.innerHeight;
    cameraLeft.updateProjectionMatrix();
    cameraRight.updateProjectionMatrix();
  });

  animate();
}

function animate(){
  requestAnimationFrame(animate);
  if(!renderer) return;

  // --- NEW: Raycasting Logic for Gaze Interaction ---
  // 1. Set the raycaster to shoot from the camera's center
  raycaster.setFromCamera(cursorPosition, cameraLeft); 
  
  // 2. Check for intersections with interactive objects
  const intersects = raycaster.intersectObjects(interactiveObjects, false);

  if (intersects.length > 0) {
    // There is an intersection
    const intersectedObject = intersects[0].object;
    
    if (INTERSECTED != intersectedObject) {
      // New object intersected - restore old object color
      if (INTERSECTED) {
        INTERSECTED.material.emissive.setHex(0x000000);
      }
      // Highlight the new object
      INTERSECTED = intersectedObject;
      INTERSECTED.material.emissive.setHex(0x303030); // Slight highlight on hover
      cursorMesh.scale.set(1.5, 1.5, 1.5); // Cursor gets slightly bigger
    }
  } else {
    // No intersection
    if (INTERSECTED) {
      // Restore the color of the object we just looked away from
      INTERSECTED.material.emissive.setHex(0x000000);
      cursorMesh.scale.set(1, 1, 1);
    }
    INTERSECTED = null;
  }
  // --- END NEW: Raycasting Logic ---

  renderer.clear();

  // Left eye
  renderer.setViewport(0,0,window.innerWidth/2,window.innerHeight);
  renderer.render(scene,cameraLeft);

  // Right eye
  renderer.setViewport(window.innerWidth/2,0,window.innerWidth/2,window.innerHeight);
  renderer.render(scene,cameraRight);
}
</script>
</body>
</html>
