<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Phone VR AR Viewer</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    touch-action: none;
  }
  #ui {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 10;
  }
  #ui.visible { opacity: 1; }
  button, input[type="range"] {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 10px;
    color: white;
    font-size: 14px;
    padding: 8px 12px;
  }
</style>
</head>
<body>
<div id="ui">
  <button id="fullscreenBtn">â›¶ Fullscreen</button>
  <input id="fovSlider" type="range" min="50" max="100" value="70">
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js";

let scene, cameraLeft, cameraRight, renderer;
let videoEl, videoTexture, videoMeshL, videoMeshR;
let fovPercent = 70;
let menu, uiVisible = false;
let lastTap = 0;
let scale = fovPercent / 100;

const ui = document.getElementById("ui");
const fovSlider = document.getElementById("fovSlider");
const fullscreenBtn = document.getElementById("fullscreenBtn");

init();
animate();

async function init() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const aspect = window.innerWidth / window.innerHeight;
  const fov = 70;
  const near = 0.01;
  const far = 100;
  const eyeGap = 0.065;

  cameraLeft = new THREE.PerspectiveCamera(fov, aspect / 2, near, far);
  cameraLeft.position.x = -eyeGap / 2;
  cameraRight = new THREE.PerspectiveCamera(fov, aspect / 2, near, far);
  cameraRight.position.x = eyeGap / 2;

  // ----- VIDEO SETUP -----
  videoEl = document.createElement("video");
  videoEl.autoplay = true;
  videoEl.playsInline = true;
  videoEl.muted = true;

  // make it renderable but invisible to user
  videoEl.style.position = "fixed";
  videoEl.style.left = "0";
  videoEl.style.top = "0";
  videoEl.style.opacity = "0";
  videoEl.style.pointerEvents = "none";
  videoEl.style.width = "1px";
  videoEl.style.height = "1px";
  document.body.appendChild(videoEl);

  // request rear camera with fallbacks
  const constraints = {
    audio: false,
    video: {
      facingMode: { ideal: "environment" },
      width: { ideal: 3840 },
      height: { ideal: 2160 }
    }
  };
  try {
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl.srcObject = stream;
  } catch (err) {
    console.warn("Camera request failed, fallback to user:", err);
    const fallbackStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" }
    });
    videoEl.srcObject = fallbackStream;
  }

  // create video texture
  videoTexture = new THREE.VideoTexture(videoEl);
  videoTexture.colorSpace = THREE.SRGBColorSpace;
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;

  const vMat = new THREE.MeshBasicMaterial({
    map: videoTexture,
    depthTest: false,
    depthWrite: false
  });

  // maintain 1.5:1 aspect ratio
  const planeGeom = new THREE.PlaneGeometry(1.5, 1);
  videoMeshL = new THREE.Mesh(planeGeom, vMat);
  videoMeshR = new THREE.Mesh(planeGeom, vMat);
  videoMeshL.position.z = -1;
  videoMeshR.position.z = -1;

  // add to scene
  scene.add(videoMeshL);
  scene.add(videoMeshR);

  // ----- MENU -----
  const menuGeom = new THREE.PlaneGeometry(0.6, 0.4, 8, 8);
  const menuMat = new THREE.MeshBasicMaterial({ color: 0x202040, transparent: true, opacity: 0.9 });
  menu = new THREE.Mesh(menuGeom, menuMat);
  menu.position.set(0, 0, -2);
  scene.add(menu);

  // tap UI
  document.addEventListener("touchstart", handleTouch);

  fullscreenBtn.addEventListener("click", () => {
    if (!document.fullscreenElement) document.body.requestFullscreen();
    else document.exitFullscreen();
  });

  fovSlider.addEventListener("input", (e) => {
    fovPercent = e.target.value;
    scale = fovPercent / 100;
    updateScale();
  });

  window.addEventListener("resize", onResize);
  onResize();

  setTimeout(() => toggleUI(false), 10000);
}

function updateScale() {
  const baseHeight = window.innerHeight * 0.7;
  const height = baseHeight * (scale / 0.7);
  const width = height * 1.5;
  const gap = 10 * (scale / 0.7);

  const totalWidth = window.innerWidth;
  const eyeWidth = width / 2;

  // left eye
  videoMeshL.scale.set(width, height, 1);
  videoMeshL.position.x = - (eyeWidth / 2 + gap / 200);
  // right eye
  videoMeshR.scale.set(width, height, 1);
  videoMeshR.position.x = (eyeWidth / 2 + gap / 200);

  // move menu along with scaling
  menu.scale.set(scale, scale, 1);
}

function handleTouch(e) {
  const now = Date.now();
  if (now - lastTap < 300) toggleMenu();
  lastTap = now;
  if (e.touches[0].clientY < window.innerHeight * 0.1) toggleUI();
}

function toggleMenu() {
  if (!menu.visible) {
    menu.visible = true;
    menu.scale.set(0, 0, 1);
    new TWEEN.Tween(menu.scale)
      .to({ x: scale, y: scale }, 400)
      .easing(TWEEN.Easing.Quadratic.Out)
      .start();
  } else {
    new TWEEN.Tween(menu.scale)
      .to({ x: 0, y: 0 }, 300)
      .easing(TWEEN.Easing.Quadratic.In)
      .onComplete(() => { menu.visible = false; })
      .start();
  }
}

function toggleUI(force) {
  if (force === undefined) uiVisible = !uiVisible;
  else uiVisible = force;
  if (uiVisible) ui.classList.add("visible");
  else ui.classList.remove("visible");
}

function onResize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
  cameraLeft.aspect = window.innerWidth / (2 * window.innerHeight);
  cameraLeft.updateProjectionMatrix();
  cameraRight.aspect = window.innerWidth / (2 * window.innerHeight);
  cameraRight.updateProjectionMatrix();
  updateScale();
}

function animate() {
  requestAnimationFrame(animate);
  if (videoEl && videoEl.readyState >= videoEl.HAVE_CURRENT_DATA) {
    videoTexture.needsUpdate = true;
  }
  if (typeof TWEEN !== "undefined") TWEEN.update();

  const halfWidth = window.innerWidth / 2;
  renderer.setScissorTest(true);

  renderer.setViewport(0, 0, halfWidth, window.innerHeight);
  renderer.setScissor(0, 0, halfWidth, window.innerHeight);
  renderer.render(scene, cameraLeft);

  renderer.setViewport(halfWidth, 0, halfWidth, window.innerHeight);
  renderer.setScissor(halfWidth, 0, halfWidth, window.innerHeight);
  renderer.render(scene, cameraRight);

  renderer.setScissorTest(false);
}
</script>

<!-- Tween.js for smooth animations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.umd.js"></script>
</body>
</html>
